{"hexoPath":"/Users/likexin/Documents/Projects/practice/blog/hexo-git","theme":"cicada","themeConfig":{"title":"Theme Config","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/themes/cicada/_config.yml","raw_content":"#======================\n#       Favicon\n#======================\nfavicon: /images/favicon.ico\n\n\n#======================\n#       Menu\n#======================\nmenu:\n  home: /\n  archives: /archives\n  portfolio: /portfolio\n  about: /about\n  # categories: /categories\n  # tags: /tags\n\n\n#======================\n#       Personal\n#======================\nshow_tag: true\nshow_category: false\n\n\n#======================\n#    Code Highlight\n#======================\n## see: https://highlightjs.org/static/demo/\nhighlight: atom-one-light\n\n\n#======================\n#     Read More\n#======================\nexcerpt_link: Read More\n\n\n#======================\n#      Fancybox\n#======================\n## see: http://fancybox.net\nfancybox: true\n\n\n#======================\n#      Comment\n#======================\ndisqus_shortname: Shingooo\n\n\n#======================\n#      RSS    \n#======================\n# rss: false | default | your feed link\n##  default: use `atom.xml`, generator for `hexo-generator-feed`\nrss: default\n\n\n#======================\n#      Social\n#======================\nsocial:\n  email: hollalikexin@gmail.com\n  instagram: https://www.instagram.com/hollalikexin/\n  douban:\n  linkedin:\n  weibo:\n  stackoverflow: https://stackoverflow.com/users/6737259/kexin-li\n  facebook:\n  twitter:\n  github: https://github.com/Kexin-Li\n  google:\n  zhihu:\n  pocket:\n\n\n#======================\n#      Friends        \n#======================\nfriends:\n  # Tom's Home: https://suyuanliu.github.io\n\n\n#======================\n#   Google Analytics\n#======================\ngoogle_analytics: UA-124632979-1\n\n\n#======================\n#      Portfolio\n#======================\nportfolio:\n  subtitle: Some Works\n  cards:\n    card1:\n      cover: /images/screenshot.png\n      content: Cicada is a concise and retro theme for Hexo.\n      link: https://github.com/Kexin-Li/hexo-theme-cicada\n    card2:\n      cover: /images/RSpotify.png\n      content: RSpotify is a Spotify Client Build with React & Redux.\n      link: https://github.com/Kexin-Li/RSpotify\n\n#======================\n#      About\n#======================\nabout:\n  subtitle: Just Another Software Engineer\n\n\n#======================\n#      今日诗词        \n#======================\n## see: https://www.jinrishici.com/\ntodaypoem: false"},"siteConfig":{"title":"Site Config","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/_config.yml","raw_content":"# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: ZERO\nsubtitle: I Must Go Seek Some Dewdrops\ndescription:\nkeywords:\nauthor: likexin\nlanguage: en-US\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://kexin-li.github.io/\nroot: /\npermalink: :lang/:year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :lang/:title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n  \n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n  \n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: cicada\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://github.com/Kexin-Li/kexin-li.github.io.git\n  branch: master\n\n# Search\nsearch: \n  path: search.xml\n  field: post\n  format: html\n  limit: 10000\n\n# RSS\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n  content:\n  content_limit: 140\n  content_limit_delim: ' '\n  order_by: -date"},"trash":[],"drafts":[{"file_name":"ajax-basic.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_drafts/ajax-basic.md","raw_content":"---\ntitle: Ajax Basic\ndate: 2018-10-08 14:18:25\ntags: network\n---\n\nAjax 是异步的 Javascript 和 XML(Asynchronous JavaScript And XML)。它使用 `XMLHTTPRequest` 对象与服务器进行通信，因为能够实现在浏览器不刷新的情况下与服务器通信并更新页面而被广泛使用。/\n\n### XMLHttpRequest 对象\n\n**构造函数**\n`const request = new XMLHttpRequest();`\n\n**方法**\n`open()`: 接受三个参数。调用这个方法并不会真正发送请求，而是启动一个请求已备发送。\n\n- 参数一，要发送的请求的类型：GET、POST 等。\n- 参数二，请求的 URL。\n- 参数三，表示是否异步发送请求的布尔值。\n\n比如：`request.open('get', 'example.php', false);`\n\n`send()`: 接受一个参数。调用这个方法后请求就会被分派到服务器。\n\n- 参数一，要作为请求主体发送的数据。如果不需要通过请求主体发送，则传入 null。\n\n`abort()`: 取消异步请求。\n\n**属性**\n收到响应后的属性有：\n\n- responseText: 作为响应主体被返回的文本。\n- responseXML: 如果响应的内容类型是 text/xml 或者 application/xml，这个属性将保存着相应数据的 XML DOM 文档。\n- status: 响应的 HTTP 状态。\n- statusText: HTTP 状态的说明。\n\n多数情况下，我们需要发送异步请求。因此可以检测 readyState 属性。该属性表示请求/响应过程的当前活动阶段。该属性可取的值为：\n\n- 0: 未初始化。尚未调用 open() 方法。\n- 1: 启动。已经调用 open() 方法，但尚未调用 send() 方法。\n- 2: 发送。已经调用 send() 方法，但尚未收到响应。\n- 3: 接收。已经接收到部分响应数据。\n- 4: 完成。已经接收到全部响应数据，而且可以在客户端使用了。\n\n只要 readyState 属性从一个值变成另外一个值，都会触发一次 onreadystatechange 事件。因此可以根据这个事件来检测请求的数据是否就位。\n\n完整例子：\n\n``` js\n// 实例化 XMLHttpRequest 对象\nconst xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4) {\n    // 已经接收到全部响应数据，而且可以在客户端使用了。\n    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n      alert(xhr.responseText);\n    } else {\n      alert('Request was unsuccessful: ' + xhr.status);\n    }\n  }\n}\n// 启动一个请求已备发送\nxhr.open('GET', 'example.php', true);\n// 发送请求\nxhr.send(null);\n```","title":"Ajax Basic","date":"2018-10-08T06:18:25.000Z","tags":"network","_content":"\nAjax 是异步的 Javascript 和 XML(Asynchronous JavaScript And XML)。它使用 `XMLHTTPRequest` 对象与服务器进行通信，因为能够实现在浏览器不刷新的情况下与服务器通信并更新页面而被广泛使用。/\n\n### XMLHttpRequest 对象\n\n**构造函数**\n`const request = new XMLHttpRequest();`\n\n**方法**\n`open()`: 接受三个参数。调用这个方法并不会真正发送请求，而是启动一个请求已备发送。\n\n- 参数一，要发送的请求的类型：GET、POST 等。\n- 参数二，请求的 URL。\n- 参数三，表示是否异步发送请求的布尔值。\n\n比如：`request.open('get', 'example.php', false);`\n\n`send()`: 接受一个参数。调用这个方法后请求就会被分派到服务器。\n\n- 参数一，要作为请求主体发送的数据。如果不需要通过请求主体发送，则传入 null。\n\n`abort()`: 取消异步请求。\n\n**属性**\n收到响应后的属性有：\n\n- responseText: 作为响应主体被返回的文本。\n- responseXML: 如果响应的内容类型是 text/xml 或者 application/xml，这个属性将保存着相应数据的 XML DOM 文档。\n- status: 响应的 HTTP 状态。\n- statusText: HTTP 状态的说明。\n\n多数情况下，我们需要发送异步请求。因此可以检测 readyState 属性。该属性表示请求/响应过程的当前活动阶段。该属性可取的值为：\n\n- 0: 未初始化。尚未调用 open() 方法。\n- 1: 启动。已经调用 open() 方法，但尚未调用 send() 方法。\n- 2: 发送。已经调用 send() 方法，但尚未收到响应。\n- 3: 接收。已经接收到部分响应数据。\n- 4: 完成。已经接收到全部响应数据，而且可以在客户端使用了。\n\n只要 readyState 属性从一个值变成另外一个值，都会触发一次 onreadystatechange 事件。因此可以根据这个事件来检测请求的数据是否就位。\n\n完整例子：\n\n``` js\n// 实例化 XMLHttpRequest 对象\nconst xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4) {\n    // 已经接收到全部响应数据，而且可以在客户端使用了。\n    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n      alert(xhr.responseText);\n    } else {\n      alert('Request was unsuccessful: ' + xhr.status);\n    }\n  }\n}\n// 启动一个请求已备发送\nxhr.open('GET', 'example.php', true);\n// 发送请求\nxhr.send(null);\n```","date_unix":1538979505000,"page_url":"_drafts/ajax-basic.md"},{"file_name":"how-javascript-works.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_drafts/how-javascript-works.md","raw_content":"---\ntitle: 解析 JavaScript 工作原理\nlang: zh\ndate: 2018-09-20 20:14:25\ntags:\n- javascript\n- how stuff works\ncover: /assets/7.jpg\n---\n","title":"解析 JavaScript 工作原理","lang":"zh","date":"2018-09-20T12:14:25.000Z","tags":["javascript","how stuff works"],"cover":"/assets/7.jpg","_content":"","date_unix":1537445665000,"page_url":"_drafts/how-javascript-works.md"},{"file_name":"how-browser-works.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_drafts/how-browser-works.md","raw_content":"---\ntitle: 浏览器呈现页面及优化相关\nlang: zh\ndate: 2018-09-19 16:23:02\ntags: \n- browser\n- how stuff works\ncover: /assets/5.jpg\n---\n\n浏览器的主要功能就是向服务器发出请求，解析收到的响应并展示出来。浏览器大概由七个部分组成，主要负责呈现页面的是[渲染引擎(Rendering Engine)](https://developer.mozilla.org/en-US/docs/Glossary/Rendering_engine)。比如 Chrome 和 Safari 使用的 [Webkit](https://webkit.org/)。\n\n呈现一个页面主要有三个阶段：解析阶段、布局阶段和绘制阶段。\n\n<!-- more -->\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/render-page.jpg\" alt=\"render page\" width=\"400\"/><figcaption>Rendering Page 流程图</figcaption></figure>\n\n## 解析阶段\n\n**解析 HTML**\n浏览器在接收到响应后，将立马执行解析 HTML 的操作，将 HTML 转换为一颗 DOM 树。大致过程可以总结为 `Characters => Tokens => Nodes => DOM`。在解析 HTML 的过程中会遵循一套规则，将 `<div>` 这样的 Tag 标签解释为浏览器能够懂的 DOM Tree。[DOM Tree](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) 是一个包含 HTML 内容和属性，以及各个节点之间关系的树结构。它与 HTML 几乎是一一对应的。\n\n首先根据语法规则，将 Character 生成对应的 Token，在生成 Token 的同时也在消耗 Token，将 Token 转换成一个 Node。当所有 Token 消耗完了，DOM Tree 也就构建好了。我认为有点类似于流水线工作。前面的工序都完成后，成品就出来了。\n\n**解析 CSS**\n解析 CSS 经历着和解析 HTML 一样的过程，`Characters => Tokens => Nodes => CSSOM`。不过语法规则不同，生成物也不同了。解析 CSS 将生成 CSSOM，它也是一颗描述 CSS 内容及属性的树。\n\n**生成渲染树(Render Tree)**\nDOM + CSSOM = Render Tree. 简单讲将 DOM Tree 中的节点都附着上对应的 CSS 的 Tree，就是 Render Tree。不过，Render Tree 只保存显示有内容的节点，即如果有节点的 CSS 是 `display: none`，那么它及它的自节点都不存在于 Render Tree 上。\n\n## 布局阶段、绘制阶段\n\n布局阶段是浏览器计算 Render Tree 上的节点在屏幕上的显示位置、尺寸等信息的步骤。绘制阶段是将 Render Tree 绘制到页面。\n\n## JavaScript\n\n为何把 JavaScript 单独拎出来？首先解析 JavaScript 的过程不是 Rendering Engine 做的事，而是 JavaScript Engine 做的事，比如 Chrome 的 [V8](https://developers.google.com/v8/)。它负责 JavaScript 的解析和执行。其次，JavaScript 作为一门解释型语言，与 HTML, CSS 不太一样，反而有很多传统语言（如 Java）的特点。\n\n略去 JavaScript 的解析与执行过程，与 HTML 大致交互过程如下。当遇到了 `<script>` 标签后，DOM 解析将暂停，直至 JS 脚本执行结束，DOM 解析再继续。这是因为 JS 既能操作 DOM 增加节点删除节点，也能操作 CSSOM 修改节点样式。\n\n当 CSSOM 还没有解析好，就遇到了 `<script>` 标签时，JS 的执行将暂停，直至 CSSOM 解析完成，再执行 JS 脚本。\n\n**async**\n在 `<script>` 标签中加上 async 关键字，DOM 的解析就不会暂停，JS 也以一种异步的方式执行。DOM 继续解析，而等 DOM 解析完成后，再执行 JS。\n\n## 优化","title":"浏览器呈现页面及优化相关","lang":"zh","date":"2018-09-19T08:23:02.000Z","tags":["browser","how stuff works"],"cover":"/assets/5.jpg","_content":"\n浏览器的主要功能就是向服务器发出请求，解析收到的响应并展示出来。浏览器大概由七个部分组成，主要负责呈现页面的是[渲染引擎(Rendering Engine)](https://developer.mozilla.org/en-US/docs/Glossary/Rendering_engine)。比如 Chrome 和 Safari 使用的 [Webkit](https://webkit.org/)。\n\n呈现一个页面主要有三个阶段：解析阶段、布局阶段和绘制阶段。\n\n<!-- more -->\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/render-page.jpg\" alt=\"render page\" width=\"400\"/><figcaption>Rendering Page 流程图</figcaption></figure>\n\n## 解析阶段\n\n**解析 HTML**\n浏览器在接收到响应后，将立马执行解析 HTML 的操作，将 HTML 转换为一颗 DOM 树。大致过程可以总结为 `Characters => Tokens => Nodes => DOM`。在解析 HTML 的过程中会遵循一套规则，将 `<div>` 这样的 Tag 标签解释为浏览器能够懂的 DOM Tree。[DOM Tree](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) 是一个包含 HTML 内容和属性，以及各个节点之间关系的树结构。它与 HTML 几乎是一一对应的。\n\n首先根据语法规则，将 Character 生成对应的 Token，在生成 Token 的同时也在消耗 Token，将 Token 转换成一个 Node。当所有 Token 消耗完了，DOM Tree 也就构建好了。我认为有点类似于流水线工作。前面的工序都完成后，成品就出来了。\n\n**解析 CSS**\n解析 CSS 经历着和解析 HTML 一样的过程，`Characters => Tokens => Nodes => CSSOM`。不过语法规则不同，生成物也不同了。解析 CSS 将生成 CSSOM，它也是一颗描述 CSS 内容及属性的树。\n\n**生成渲染树(Render Tree)**\nDOM + CSSOM = Render Tree. 简单讲将 DOM Tree 中的节点都附着上对应的 CSS 的 Tree，就是 Render Tree。不过，Render Tree 只保存显示有内容的节点，即如果有节点的 CSS 是 `display: none`，那么它及它的自节点都不存在于 Render Tree 上。\n\n## 布局阶段、绘制阶段\n\n布局阶段是浏览器计算 Render Tree 上的节点在屏幕上的显示位置、尺寸等信息的步骤。绘制阶段是将 Render Tree 绘制到页面。\n\n## JavaScript\n\n为何把 JavaScript 单独拎出来？首先解析 JavaScript 的过程不是 Rendering Engine 做的事，而是 JavaScript Engine 做的事，比如 Chrome 的 [V8](https://developers.google.com/v8/)。它负责 JavaScript 的解析和执行。其次，JavaScript 作为一门解释型语言，与 HTML, CSS 不太一样，反而有很多传统语言（如 Java）的特点。\n\n略去 JavaScript 的解析与执行过程，与 HTML 大致交互过程如下。当遇到了 `<script>` 标签后，DOM 解析将暂停，直至 JS 脚本执行结束，DOM 解析再继续。这是因为 JS 既能操作 DOM 增加节点删除节点，也能操作 CSSOM 修改节点样式。\n\n当 CSSOM 还没有解析好，就遇到了 `<script>` 标签时，JS 的执行将暂停，直至 CSSOM 解析完成，再执行 JS 脚本。\n\n**async**\n在 `<script>` 标签中加上 async 关键字，DOM 的解析就不会暂停，JS 也以一种异步的方式执行。DOM 继续解析，而等 DOM 解析完成后，再执行 JS。\n\n## 优化","date_unix":1537345382000,"page_url":"_drafts/how-browser-works.md"},{"file_name":"test.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_drafts/test.md","raw_content":"---\ntitle: 北韓專政政權的金日成(Kim Il Sung)共同抗擊日本軍隊\nlang: zh\ndate: 2018-08-28 19:00:56\ntags: Markdown\ncover: /assets/2.jpg\n---\n在今年6月金正恩與美國總統特朗普(Trump)舉行峰會後，中國和北韓的官方媒體均強調了經濟機遇，暗示出對恢復貿易的渴望。在特金會兩周後，北韓報紙《勞動新聞》(Rodong Sinmun)在一篇文章中援引周家的話稱，中朝關係是友好的。\n\n## 華爾街日報\n\n本文原刊於《華爾街日報》，端傳媒獲授權轉載。目前，《華爾街日報》中文版全部內容僅向付費會員開放，我們強烈推薦您購買/升級成為「端傳媒尊享會員」，以低於原價 70% 的價格，暢讀端傳媒和《華爾街日報》全部內容。\n\n80年前，一位名叫周保中的中國將領曾與後來建立了北韓專政政權的金日成(Kim Il Sung)共同抗擊日本軍隊。\n\n這一戰場上的聯盟此後演變為已延續三代的友誼，成為一段對中朝這兩個毗鄰的共產主義國家有很高宣傳價值的家族故事。\n\n這段友誼也為日後的商貿往來奠定了基礎，成為北韓經濟長期以來依賴的命脈——來自中國的貿易和投資的一部分。如果當前針對北韓的國際制裁放鬆，北韓可能會重獲這一支持。\n\n據《華爾街日報》(The Wall Street Journal)的一項調查，在北韓政府將大量國家收入投入武器開發期間，與周家有關聯的企業幫助北韓增加了財富。從企業記錄、官方媒體報道和採訪可以看出，周家與包括礦業、貿易和消費品在內的北韓多個行業有關聯。\n\n## 制裁使中國與北韓的貿易減少\n\n過去一年，制裁使中國與北韓的貿易減少。一位周家人對《華爾街日報》稱，周家在北韓沒有生意。 不過，周金兩家的關係保持下來。據知情人士和官方報道稱，過去兩年，周家家族代表支持北韓領導人金正恩(Kim Jong Un)的軍事追求，參加金正恩在平壤安排的招待會，並在北韓進行黃金勘探，4月份還進行了為期一周的訪問。\n\n北韓的三代領導人都曾迎接周保中今年76歲的女兒周偉的到訪，將她對北韓的訪問稱為兩國共同 “抗日革命戰爭”的永恆紀念。\n\n原文：《華爾街日報：解放軍將領周保中家族在北韓經濟發展中扮演的角色》 https://theinitium.com/article/20180906-wsj-chinas-northkorea-zhoufamily/20180906-wsj-chinas-northkorea-zhoufamily \n© 端傳媒 Initium Media\n\n### 家族友誼帶來了商業契機\n\n北韓媒體紀錄了周偉的部分年度平壤之行，她向金日成紀念堂(Kim Il Sung Mausoleum)敬獻了一個寫有“永垂不朽，周偉家族上”的花圈，並稱北韓人民“緊密團結在金正恩元帥周圍”。\n\n家族友誼帶來了商業契機。《華爾街日報》在中國發現了三家公司的官方注冊文件，其中包括周偉的旗艦企業丹東偉民國際商貿有限責任公司(Dandong Weimin International Trade Co. 簡稱：偉民公司)，周偉本人、她的丈夫和兩個女兒均是該公司的股東或董事。北韓和中國官方媒體會在有關北韓採礦、貿易和其他商業活動的報道中透露上述業務和關聯企業。\n\n在中國，偉民公司數年前宣傳其顧問服務時稱，公司擁有20年經驗，可以幫助解決對朝投資中出現的任何問題。\n\n關於該公司在北韓業務及財務表現方面的細節基本上不得而知。偉民公司接電話的人士沒有回答《華爾街日報》的問題。其在中朝鴨綠江大橋附近丹東的注冊地址是一個能停一輛車的車庫，在這裏停車的家庭表示不知情。\n\n周偉此前工作的軍隊醫院的記錄顯示，她是一名軍隊退休醫生，居住在天安門廣場附近的一個幹部大院。當一名《華爾街日報》記者今年3月份在她住所敲門時，開門的是周偉的丈夫矛維然。\n\n在門口接受簡短採訪時，矛維然對於關於北韓的問題回答稱：「我們不做生意。」他禮貌地把相關問題推給了中國軍方，因為他們倆都是軍隊退休幹部。軍方未作回覆。這家人未回應書面提問。\n\n去年，中國加入美國以及聯合國其他一些成員國的行列，禁止了大部分對朝貿易和對朝投資，以制裁北韓發展核武器之舉。在那之前的十餘年時間里，中國公司幫助對北韓的礦業和工廠進行了現代化改造，令北韓得以推進自己的核武器計劃。\n\n美國中央情報局(CIA)一份已解密的彙編文件列出了351家北韓與外國合資的企業，其中包括偉民公司投資的一個礦業項目。這些合資企業誕生於本世紀早些時候北韓與外國的一波合作熱潮，吸引了至少23.2億美元投資，75%的合作夥伴是中國企業。\n\n韓國央行的數據顯示，受制裁拖累，北韓經濟去年萎縮了3.5%，為1997年以來最嚴重的一次下滑。與2016年的增長3.9%相比，這是一次痛苦的轉向。\n\n在今年6月金正恩與美國總統特朗普(Trump)舉行峰會後，中國和北韓的官方媒體均強調了經濟機遇，暗示出對恢復貿易的渴望。在特金會兩周後，北韓報紙《勞動新聞》(Rodong Sinmun)在一篇文章中援引周家的話稱，中朝關係是友好的。\n\n### 中國企業家就會迅速抓住機會\n\n如果聯合國放鬆對北韓的制裁，中國企業家就會迅速抓住機會。華盛頓的美國企業研究所(American Enterprise Institute)的Nicholas Eberstadt稱：「好像他們一夜之間就可以把開關打開。」\n\n今年3月份金正恩訪問北京時，中國國家主席習近平提到了當年老一輩領導人如何建立了“深厚的革命友誼”。這是金正恩2011年掌權以來首次出國訪問。周保中與金正恩的祖父金日成的傳奇友情成為了中朝關係的一個紐帶。\n\n20世紀30年代末，周保中與金日成聯合抗擊日本對東北亞的侵略，當時周保中把金日成介紹給了蘇聯軍事顧問。兩人建立了供應和通信線，金日成記述了「革命同志之間的友誼」。\n\n歷史學家淡化了他們在戰爭中的英雄主義，但沒有忽略他們的私人關係。上海的歷史學家沈志華說，周保中和金日成曾關係密切，格外的密切；他們曾生死與共，同仇敵愾。\n\n原文：《華爾街日報：解放軍將領周保中家族在北韓經濟發展中扮演的角色》 https://theinitium.com/article/20180906-wsj-chinas-northkorea-zhoufamily/ \n© 端傳媒 Initium Media","title":"北韓專政政權的金日成(Kim Il Sung)共同抗擊日本軍隊","lang":"zh","date":"2018-08-28T11:00:56.000Z","tags":"Markdown","cover":"/assets/2.jpg","_content":"在今年6月金正恩與美國總統特朗普(Trump)舉行峰會後，中國和北韓的官方媒體均強調了經濟機遇，暗示出對恢復貿易的渴望。在特金會兩周後，北韓報紙《勞動新聞》(Rodong Sinmun)在一篇文章中援引周家的話稱，中朝關係是友好的。\n\n## 華爾街日報\n\n本文原刊於《華爾街日報》，端傳媒獲授權轉載。目前，《華爾街日報》中文版全部內容僅向付費會員開放，我們強烈推薦您購買/升級成為「端傳媒尊享會員」，以低於原價 70% 的價格，暢讀端傳媒和《華爾街日報》全部內容。\n\n80年前，一位名叫周保中的中國將領曾與後來建立了北韓專政政權的金日成(Kim Il Sung)共同抗擊日本軍隊。\n\n這一戰場上的聯盟此後演變為已延續三代的友誼，成為一段對中朝這兩個毗鄰的共產主義國家有很高宣傳價值的家族故事。\n\n這段友誼也為日後的商貿往來奠定了基礎，成為北韓經濟長期以來依賴的命脈——來自中國的貿易和投資的一部分。如果當前針對北韓的國際制裁放鬆，北韓可能會重獲這一支持。\n\n據《華爾街日報》(The Wall Street Journal)的一項調查，在北韓政府將大量國家收入投入武器開發期間，與周家有關聯的企業幫助北韓增加了財富。從企業記錄、官方媒體報道和採訪可以看出，周家與包括礦業、貿易和消費品在內的北韓多個行業有關聯。\n\n## 制裁使中國與北韓的貿易減少\n\n過去一年，制裁使中國與北韓的貿易減少。一位周家人對《華爾街日報》稱，周家在北韓沒有生意。 不過，周金兩家的關係保持下來。據知情人士和官方報道稱，過去兩年，周家家族代表支持北韓領導人金正恩(Kim Jong Un)的軍事追求，參加金正恩在平壤安排的招待會，並在北韓進行黃金勘探，4月份還進行了為期一周的訪問。\n\n北韓的三代領導人都曾迎接周保中今年76歲的女兒周偉的到訪，將她對北韓的訪問稱為兩國共同 “抗日革命戰爭”的永恆紀念。\n\n原文：《華爾街日報：解放軍將領周保中家族在北韓經濟發展中扮演的角色》 https://theinitium.com/article/20180906-wsj-chinas-northkorea-zhoufamily/20180906-wsj-chinas-northkorea-zhoufamily \n© 端傳媒 Initium Media\n\n### 家族友誼帶來了商業契機\n\n北韓媒體紀錄了周偉的部分年度平壤之行，她向金日成紀念堂(Kim Il Sung Mausoleum)敬獻了一個寫有“永垂不朽，周偉家族上”的花圈，並稱北韓人民“緊密團結在金正恩元帥周圍”。\n\n家族友誼帶來了商業契機。《華爾街日報》在中國發現了三家公司的官方注冊文件，其中包括周偉的旗艦企業丹東偉民國際商貿有限責任公司(Dandong Weimin International Trade Co. 簡稱：偉民公司)，周偉本人、她的丈夫和兩個女兒均是該公司的股東或董事。北韓和中國官方媒體會在有關北韓採礦、貿易和其他商業活動的報道中透露上述業務和關聯企業。\n\n在中國，偉民公司數年前宣傳其顧問服務時稱，公司擁有20年經驗，可以幫助解決對朝投資中出現的任何問題。\n\n關於該公司在北韓業務及財務表現方面的細節基本上不得而知。偉民公司接電話的人士沒有回答《華爾街日報》的問題。其在中朝鴨綠江大橋附近丹東的注冊地址是一個能停一輛車的車庫，在這裏停車的家庭表示不知情。\n\n周偉此前工作的軍隊醫院的記錄顯示，她是一名軍隊退休醫生，居住在天安門廣場附近的一個幹部大院。當一名《華爾街日報》記者今年3月份在她住所敲門時，開門的是周偉的丈夫矛維然。\n\n在門口接受簡短採訪時，矛維然對於關於北韓的問題回答稱：「我們不做生意。」他禮貌地把相關問題推給了中國軍方，因為他們倆都是軍隊退休幹部。軍方未作回覆。這家人未回應書面提問。\n\n去年，中國加入美國以及聯合國其他一些成員國的行列，禁止了大部分對朝貿易和對朝投資，以制裁北韓發展核武器之舉。在那之前的十餘年時間里，中國公司幫助對北韓的礦業和工廠進行了現代化改造，令北韓得以推進自己的核武器計劃。\n\n美國中央情報局(CIA)一份已解密的彙編文件列出了351家北韓與外國合資的企業，其中包括偉民公司投資的一個礦業項目。這些合資企業誕生於本世紀早些時候北韓與外國的一波合作熱潮，吸引了至少23.2億美元投資，75%的合作夥伴是中國企業。\n\n韓國央行的數據顯示，受制裁拖累，北韓經濟去年萎縮了3.5%，為1997年以來最嚴重的一次下滑。與2016年的增長3.9%相比，這是一次痛苦的轉向。\n\n在今年6月金正恩與美國總統特朗普(Trump)舉行峰會後，中國和北韓的官方媒體均強調了經濟機遇，暗示出對恢復貿易的渴望。在特金會兩周後，北韓報紙《勞動新聞》(Rodong Sinmun)在一篇文章中援引周家的話稱，中朝關係是友好的。\n\n### 中國企業家就會迅速抓住機會\n\n如果聯合國放鬆對北韓的制裁，中國企業家就會迅速抓住機會。華盛頓的美國企業研究所(American Enterprise Institute)的Nicholas Eberstadt稱：「好像他們一夜之間就可以把開關打開。」\n\n今年3月份金正恩訪問北京時，中國國家主席習近平提到了當年老一輩領導人如何建立了“深厚的革命友誼”。這是金正恩2011年掌權以來首次出國訪問。周保中與金正恩的祖父金日成的傳奇友情成為了中朝關係的一個紐帶。\n\n20世紀30年代末，周保中與金日成聯合抗擊日本對東北亞的侵略，當時周保中把金日成介紹給了蘇聯軍事顧問。兩人建立了供應和通信線，金日成記述了「革命同志之間的友誼」。\n\n歷史學家淡化了他們在戰爭中的英雄主義，但沒有忽略他們的私人關係。上海的歷史學家沈志華說，周保中和金日成曾關係密切，格外的密切；他們曾生死與共，同仇敵愾。\n\n原文：《華爾街日報：解放軍將領周保中家族在北韓經濟發展中扮演的角色》 https://theinitium.com/article/20180906-wsj-chinas-northkorea-zhoufamily/ \n© 端傳媒 Initium Media","date_unix":1535454056000,"page_url":"_drafts/test.md"}],"pages":[{"file_name":"index.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/notion/index.md","raw_content":"---\ntitle: notion\ndate: 2018-09-12 20:07:31\nlayout: notion\n---\n","title":"notion","date":"2018-09-12T12:07:31.000Z","layout":"notion","_content":"","date_unix":1536754051000,"page_url":"notion/index.md"},{"file_name":"index.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/categories/index.md","raw_content":"---\ntitle: categories\ndate: 2018-09-05 10:55:26\nlayout: categories\n---\n","title":"categories","date":"2018-09-05T02:55:26.000Z","layout":"categories","_content":"","date_unix":1536116126000,"page_url":"categories/index.md"},{"file_name":"index.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/tags/index.md","raw_content":"---\ntitle: tags\ndate: 2018-09-05 10:49:33\nlayout: tags\n---\n","title":"tags","date":"2018-09-05T02:49:33.000Z","layout":"tags","_content":"","date_unix":1536115773000,"page_url":"tags/index.md"},{"file_name":"index.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/about/index.md","raw_content":"---\ntitle: About Me\ndate: 2018-08-26 20:29:16\nlayout: page\ncover: /assets/1.jpg\n---\n\n---\n喜欢互联网行业，这个行业有很多热爱思考的人。\n\n相信科技不会改变世界，能改变世界的是每个人富饶的精神世界。\n\n**Tech won't change the world.**","title":"About Me","date":"2018-08-26T12:29:16.000Z","layout":"page","cover":"/assets/1.jpg","_content":"\n---\n喜欢互联网行业，这个行业有很多热爱思考的人。\n\n相信科技不会改变世界，能改变世界的是每个人富饶的精神世界。\n\n**Tech won't change the world.**","date_unix":1535286556000,"page_url":"about/index.md"},{"file_name":"index.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/portfolio/index.md","raw_content":"---\ntitle: portfolio\ndate: 2018-08-26 20:29:16\nlayout: portfolio\n---","title":"portfolio","date":"2018-08-26T12:29:16.000Z","layout":"portfolio","_content":"","date_unix":1535286556000,"page_url":"portfolio/index.md"}],"posts":[{"file_name":"react-component-lifecycle.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/react-component-lifecycle.md","raw_content":"---\ntitle: React 组件生命周期\nlang: zh\ndate: 2018-10-21 11:15:18\ncover: /assets/react-lifecycle.jpg\ntags:\n- react\n---\n\n> 本文针对 React v16.3 及之后的版本。React v16.3 废除了在 render 函数之前执行的三个生命周期函数，包括 componentWillReceiveProps, componentWillMount 和 componentWillUpdate。原因是 React Fiber 的引入，它采用了分片的渲染方式，从同步渲染转为异步渲染，会导致 render() 函数之前的生命周期函数被多次执行。\n\n<!-- more -->\n\nReact 组件生命周期将经历三个阶段：\n\n- 装载阶段(mount)：第一次把组件渲染到 DOM 的阶段。\n- 更新阶段(update)：当 React 的数据，也就是 state 或者 props 发生改变时，对组件进行更新渲染的阶段。\n- 卸载阶段(unmount)：将组件从 DOM 删除的阶段。\n\n每个阶段有各自的生命周期函数，下面分阶段描述各自的生命周期函数。\n\n在 React v16.3 之后，废除了在 render 函数之前执行的三个生命周期函数，包括 componentWillReceiveProps, componentWillMount 和 componentWillUpdate，下文将不再赘述这三个生命周期。\n\n---\n\n## mount\n\n与 mount 阶段相关的生命周期函数有：\n\n- constructor()\n- static getDerivedStateFromProps(nextProps, prevState)\n- render()\n- componentDidMount()\n\n**constructor**\n构造函数，经常为了初始化 state 或者绑定成员函数的 this 环境。如果没有上面两种需求，那么就无需实现这个函数。绑定 this 环境可以通过 ES6 的箭头解决，另外，不应该在 constructor 函数中进行 setState 的操作，而应该直接为 this.state 赋值。也不应该将 props 的值赋给 state。\n\n**getDerivedStateFromProps**\ngetDerivedStateFromProps 函数是一个静态函数，意味着函数体内拿不到 this 值。通常在这里做一些 props 与 state 的对比操作，从而更新 this.state 的值。getDerivedStateFromProps 返回的值将自动送到 this.setState 中。另外，不应该在这里做请求操作，而应该视情况分配到 componentDidMount 或者 componentDidUpdate 中。\n\nBy the way，getDerivedStateFromProps 函数在 mounting 和 updating 阶段都会被调用，而且不管是 props 引起的 updating 还是 state 引起的 updating。React 的用意大概是进一步约束了开发者只能在 getDerivedStateFromProps 中作没有副作用的比对操作。\n\n**render**\nrender 函数用于渲染组件，是必需实现的函数。在装载组件时会调用 render(函数，在 props 或者 state 更新时也可能调用(当 shouldComponentUpdate 返回 false 时就不会调用)。render 函数是一个纯函数，它不会修改 state 的值。\n\nrender 函数的返回值有以下几种：\n\n- React element\n- Arrays and fragments\n- Portals\n- String and number\n- Booleans or null\n\n常用的返回值是 React element，通常是由 JSX 编写的，element 是一个 JavaScript Object，保存着组件的各种信息。当返回 null 时，代表不需要渲染该组件。\n\n**componentDidMount**\ncomponentDidMount 将会在组件被加载到 DOM 树后调用，它并不是 render 函数执行完毕就调用，因为 render 函数只是返回了 JSX 对象或 String 等其他东西，而非真正挂载到 DOM 树中。另外，componentDidMount函数在进行服务器端渲染时不会被调用。\n\ncomponentDidMount 通常用于服务器数据的拉取操作，之所以在 componentDidMount 中而不是在构造函数中进行数据拉取的原因在于：如果数据拉取回来了，即 props 已经有值了，但是组件还没有渲染出来，会报错。\n\n> 但是这里有一些把数据拉取提前到 constructor 函数的思路：在 contructor 函数中，通过 promise 来进行数据的拉取，并且绑定到 this 对象上，然后在 componentDidMount 中执行 promise 把数据更新到 props 上。\n\n---\n\n## update\n\n当组件挂载到 DOM 树上之后，props/state 被修改会导致组件进行更新操作。与 update 阶段相关的生命周期函数有：\n\n- static getDerivedStateFromProps(nextProps, prevState)\n- shouldComponentUpdate(nextProps, nextState)\n- render()\n- getSnapshotBeforeUpdate(prevProps, prevState)\n- componentDidUpdate(prevProps, prevState, snapshot)\n\n**shouldComponentUpdate**\nshouldComponentUpdate 函数旨在告诉 React 当前更新的 state 或 props 会不会影响当前组件的渲染，常用于性能的优化。\n\n**getSnapshotBeforeUpdate**\ngetSnapshotBeforeUpdate 在 render 之后执行，但此时组件还没有更新到 DOM 上，getSnapshotBeforeUpdate 此时可以获取 DOM 的值，计算得到一个 snapshot，可以作为第三个参数传入下面的 componentDidUpdate 中。(PS: 这个应该不常用吧...)\n\n**componentDidUpdate**\n更新完成后将调用 componentDidUpdate 函数，常用于比对 props 或 state 的变化而做一些发起请求的操作。如果之前有调用 getSnapshotBeforeUpdate 函数，那么其返回值将作为第三个参数传入 componentDidUpdate 函数，否则的话第三个参数为 undefined。\n\n``` js\ncomponentDidUpdate(prevProps) {\n  // Typical usage (don't forget to compare props):\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n```\n\n---\n\n## unmount\n\n与 unmount 阶段相关的生命周期函数有：\n\n- componentWillUnmount()\n\n当组件将要被卸载时将调用 componentWillUnmount 函数，当 React 组件要从 DOM 树上删除前，会调用一次这个函数。这个函数经常用于去除 componentDidMount 函数带来的副作用，例如清楚计时器、删除 componentDidMount 中创造的非 React 元素。\n\n---\n\n## Wrap-up\n\nReact v16 还引入了另外一个声明周期函数，即 componentDidCatch，用于捕获错误。\n\n用一张图来总结 React 的组件生命周期，其中对于 getDerivedStateFromProps 的描述不太准确，不管是 new props，setState 还是 forceUpdate，都应该会调用 getDerivedStateFromProps 函数。\n\n我在 [CodeSandBox](https://codesandbox.io/s/yzkqzo55v) 上做了个小例子证明了不论是 props 的改变还是 state 的改变，或者是调用 forceUpdate 都会调用 getDerivedStateFromProps 函数。\n\n<figure><img src=\"/assets/react-lifecycle.jpg\" alt=\"React LifeCycle\"/><figcaption><a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">图片来源</a></figcaption></figure>","title":"React 组件生命周期","lang":"zh","date":"2018-10-21T03:15:18.000Z","cover":"/assets/react-lifecycle.jpg","tags":["react"],"_content":"\n> 本文针对 React v16.3 及之后的版本。React v16.3 废除了在 render 函数之前执行的三个生命周期函数，包括 componentWillReceiveProps, componentWillMount 和 componentWillUpdate。原因是 React Fiber 的引入，它采用了分片的渲染方式，从同步渲染转为异步渲染，会导致 render() 函数之前的生命周期函数被多次执行。\n\n<!-- more -->\n\nReact 组件生命周期将经历三个阶段：\n\n- 装载阶段(mount)：第一次把组件渲染到 DOM 的阶段。\n- 更新阶段(update)：当 React 的数据，也就是 state 或者 props 发生改变时，对组件进行更新渲染的阶段。\n- 卸载阶段(unmount)：将组件从 DOM 删除的阶段。\n\n每个阶段有各自的生命周期函数，下面分阶段描述各自的生命周期函数。\n\n在 React v16.3 之后，废除了在 render 函数之前执行的三个生命周期函数，包括 componentWillReceiveProps, componentWillMount 和 componentWillUpdate，下文将不再赘述这三个生命周期。\n\n---\n\n## mount\n\n与 mount 阶段相关的生命周期函数有：\n\n- constructor()\n- static getDerivedStateFromProps(nextProps, prevState)\n- render()\n- componentDidMount()\n\n**constructor**\n构造函数，经常为了初始化 state 或者绑定成员函数的 this 环境。如果没有上面两种需求，那么就无需实现这个函数。绑定 this 环境可以通过 ES6 的箭头解决，另外，不应该在 constructor 函数中进行 setState 的操作，而应该直接为 this.state 赋值。也不应该将 props 的值赋给 state。\n\n**getDerivedStateFromProps**\ngetDerivedStateFromProps 函数是一个静态函数，意味着函数体内拿不到 this 值。通常在这里做一些 props 与 state 的对比操作，从而更新 this.state 的值。getDerivedStateFromProps 返回的值将自动送到 this.setState 中。另外，不应该在这里做请求操作，而应该视情况分配到 componentDidMount 或者 componentDidUpdate 中。\n\nBy the way，getDerivedStateFromProps 函数在 mounting 和 updating 阶段都会被调用，而且不管是 props 引起的 updating 还是 state 引起的 updating。React 的用意大概是进一步约束了开发者只能在 getDerivedStateFromProps 中作没有副作用的比对操作。\n\n**render**\nrender 函数用于渲染组件，是必需实现的函数。在装载组件时会调用 render(函数，在 props 或者 state 更新时也可能调用(当 shouldComponentUpdate 返回 false 时就不会调用)。render 函数是一个纯函数，它不会修改 state 的值。\n\nrender 函数的返回值有以下几种：\n\n- React element\n- Arrays and fragments\n- Portals\n- String and number\n- Booleans or null\n\n常用的返回值是 React element，通常是由 JSX 编写的，element 是一个 JavaScript Object，保存着组件的各种信息。当返回 null 时，代表不需要渲染该组件。\n\n**componentDidMount**\ncomponentDidMount 将会在组件被加载到 DOM 树后调用，它并不是 render 函数执行完毕就调用，因为 render 函数只是返回了 JSX 对象或 String 等其他东西，而非真正挂载到 DOM 树中。另外，componentDidMount函数在进行服务器端渲染时不会被调用。\n\ncomponentDidMount 通常用于服务器数据的拉取操作，之所以在 componentDidMount 中而不是在构造函数中进行数据拉取的原因在于：如果数据拉取回来了，即 props 已经有值了，但是组件还没有渲染出来，会报错。\n\n> 但是这里有一些把数据拉取提前到 constructor 函数的思路：在 contructor 函数中，通过 promise 来进行数据的拉取，并且绑定到 this 对象上，然后在 componentDidMount 中执行 promise 把数据更新到 props 上。\n\n---\n\n## update\n\n当组件挂载到 DOM 树上之后，props/state 被修改会导致组件进行更新操作。与 update 阶段相关的生命周期函数有：\n\n- static getDerivedStateFromProps(nextProps, prevState)\n- shouldComponentUpdate(nextProps, nextState)\n- render()\n- getSnapshotBeforeUpdate(prevProps, prevState)\n- componentDidUpdate(prevProps, prevState, snapshot)\n\n**shouldComponentUpdate**\nshouldComponentUpdate 函数旨在告诉 React 当前更新的 state 或 props 会不会影响当前组件的渲染，常用于性能的优化。\n\n**getSnapshotBeforeUpdate**\ngetSnapshotBeforeUpdate 在 render 之后执行，但此时组件还没有更新到 DOM 上，getSnapshotBeforeUpdate 此时可以获取 DOM 的值，计算得到一个 snapshot，可以作为第三个参数传入下面的 componentDidUpdate 中。(PS: 这个应该不常用吧...)\n\n**componentDidUpdate**\n更新完成后将调用 componentDidUpdate 函数，常用于比对 props 或 state 的变化而做一些发起请求的操作。如果之前有调用 getSnapshotBeforeUpdate 函数，那么其返回值将作为第三个参数传入 componentDidUpdate 函数，否则的话第三个参数为 undefined。\n\n``` js\ncomponentDidUpdate(prevProps) {\n  // Typical usage (don't forget to compare props):\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n```\n\n---\n\n## unmount\n\n与 unmount 阶段相关的生命周期函数有：\n\n- componentWillUnmount()\n\n当组件将要被卸载时将调用 componentWillUnmount 函数，当 React 组件要从 DOM 树上删除前，会调用一次这个函数。这个函数经常用于去除 componentDidMount 函数带来的副作用，例如清楚计时器、删除 componentDidMount 中创造的非 React 元素。\n\n---\n\n## Wrap-up\n\nReact v16 还引入了另外一个声明周期函数，即 componentDidCatch，用于捕获错误。\n\n用一张图来总结 React 的组件生命周期，其中对于 getDerivedStateFromProps 的描述不太准确，不管是 new props，setState 还是 forceUpdate，都应该会调用 getDerivedStateFromProps 函数。\n\n我在 [CodeSandBox](https://codesandbox.io/s/yzkqzo55v) 上做了个小例子证明了不论是 props 的改变还是 state 的改变，或者是调用 forceUpdate 都会调用 getDerivedStateFromProps 函数。\n\n<figure><img src=\"/assets/react-lifecycle.jpg\" alt=\"React LifeCycle\"/><figcaption><a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">图片来源</a></figcaption></figure>","date_unix":1540091718000,"page_url":"_posts/zh/react-component-lifecycle.md"},{"file_name":"sorting-algorithm.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/sorting-algorithm.md","raw_content":"---\ntitle: 排序算法总结\nlang: zh\ndate: 2018-10-13 21:08:03\ntags:\n- algorithm\n---\n\n本文记录了常用的排序算法，按照时间复杂度的分类方式，分为时间复杂度为 `O(n^2)` 的算法，`O(nlogn)` 的算法和 `O(n)` 的算法依次讲解。\n\n<!-- more -->\n\n## 时间复杂度为 O(n^2) 的算法\n\n常见的时间复杂度为 `O(n^2)` 的算法有冒泡排序，选择排序以及插入排序。\n\n### 冒泡排序\n\n首先是第一个数和第二个数进行比较，谁大谁在后面，接着第二个数和第三个数进行比较，谁大谁在后面。以此类推，经过一轮比较下来最大的数就沉到了最后一位。将数组范围缩小到 0-N-1，再经历一轮第二大的数就在倒数第二的位置。以此类推，当数组范围只剩一个数时，数组就变得有序了。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/BubbleSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/BubbleSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif'>图片来源</a></figcaption></figure>\n\n### 选择排序\n\n首先在整个数组中选出最小的数放在最前面，接着在剩下的数组中选出最小的数放在第二个位置。以此类推，当剩下的数组只剩一个数时，整个数组就变得有序了。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/SelectSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/SelectSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif'>图片来源</a></figcaption></figure>\n\n### 插入排序\n\n首先将第二个位置和第一个位置的数进行比较，谁小谁在前。第三个位置上的数和第一、二个位置上的数比较，插入合适的位置。第四个位置上的数和第一、二、三个位置上的数比较，插入合适的位置。以此类推，当安顿好了数组的最后一个数，整个数组也变得有序了。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/InsertSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/InsertSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif'>图片来源</a></figcaption></figure>\n\n## 时间复杂度为 O(nlogn) 的算法\n\n常见的时间复杂度为 `O(nlogn)` 的算法有归并排序、快速排序、堆排序以及希尔排序。\n\n### 归并排序\n\n首先将数组中的每一个数看作长度为 1 的有序序列，然后把相邻的有序序列进行合并操作，得到最大长度为 2 的有序序列。接着再把相邻序列进行合并，得到\b最大程度为 4 的有序序列。以此类推，直到数组中的所有数合并成一个有序序列。\n\n所以归并排序的思想在于**将两两有序序列合并成一个有序序列**。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/MergeSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/MergeSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif'>图片来源</a></figcaption></figure>\n\n### 快速排序\n\n首先在数组中随机选一个作为基准数(一般选择中点位置的数)，接着将数组中小于等于基准数的放到数组左边，大于基准数的放到数组右边，使得整个数组整体有序。然后再对左右两边分别递归调用上述过程，从而使整个数组有序。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/QuickSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/QuickSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif'>图片来源</a></figcaption></figure>\n\n### 堆排序\n\n首先将数组中的 N 个数建成一个大小为 N 的大根堆，堆顶是所有元素中的最大值，将堆顶元素与堆的最后一个元素进行交换，将最大值脱离堆并作为有序部分放在数组的末尾。接着调整大根堆，将剩下元素的最大值放在堆顶然后脱离堆，加入有序部分。以此类推，当堆只剩下一个元素时，整个数组就有序了。\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif'>图片来源</a></figcaption></figure>\n\n### 希尔排序\n\n希尔排序是插入排序的改良版。插入排序的步长是 1，希尔排序的步长是从大到小逐渐调整的。\n\n初始的步长需要我们来制定，比如 `6 5 3 1 8 7 2 4` 这个数组，我们选择初始步长为 3，那么 `6 5 3` 这前三个数可以暂不做调整。接着从 1 开始向前跳三位，与 6 进行比较，进而交换位置，再往前跳三位由于越界了所以不作调整了。然后看 8 这位数，向前跳三位与 5 比较，由于 8 > 5 所以不做调整。以此调整完整个数组，再修改步长为 2 和 1 再分别对数组做调整。\n\n希尔排序的时间复杂度高低完全取决于步长的选择，步长选择越优那么它的时间复杂度越低，反之时间复杂度就越高。\n\n## 时间复杂度为 O(n) 的算法\n\n时间复杂度为 `O(n)` 的算法都不是基于比较的思想，而是基于[桶排序](https://zh.wikipedia.org/zh-hant/%E6%A1%B6%E6%8E%92%E5%BA%8F)的思想。常见的有计数排序和基数排序。\n\n### 计数排序\n\n详见[计数排序](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)\n\n### 基数排序\n\n详见[基数排序](https://zh.wikipedia.org/zh-hant/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)\n\n## 总结\n\n| 名称 | 时间复杂度 | 空间复杂度 | 稳定性 |\n| --- | :---: | :---: | :---: |\n| 冒泡排序 | `O(n^2)` | `O(1)` | 稳定 |\n| 选择排序 | `O(n^2)` | `O(1)` | 不稳定 |\n| 插入排序 | `O(n^2)` | `O(1)`| 稳定 |\n| 归并排序 | `O(n*logn)` | `O(n)`| 稳定 |\n| 快速排序 | `O(n*logn)` | `O(logn)` ~ `O(n)` | 不稳定 |\n| 堆排序 | `O(n*logn)` | `O(1)` | 不稳定 |\n| 希尔排序 | `O(n*logn)` | `O(1)` | 不稳定 |\n| 计数排序 | `O(n)` | `O(m)` | 稳定 |\n| 基数排序 | `O(n)` | `O(m)` | 稳定 |\n\n**Notes：**\n\n- 计数排序与基数排序中的空间复杂度 `O(m)` 中的 m 指的是桶的数量。\n- 稳定性：指相同值的元素在排序前和排序后的相对次序是否保持不变。\n- 桶排序虽然时间复杂度高，但可以理解为是一种空间换时间的思想。当数据量很大时，需要准备的桶也就越多，会一定程序造成空间的浪费。因此具有很大的局限性。\n- 快速排序之所以叫快速排序，不是因为它比堆排序、归并排序更优良，而是因为它的常量系数比较低。\n- 在工程中，并不会特定使用某一种排序，而是综合使用。比如当元素个数比较少时，会使用插入排序；当元素个数较多时，会使用快速排序。","title":"排序算法总结","lang":"zh","date":"2018-10-13T13:08:03.000Z","tags":["algorithm"],"_content":"\n本文记录了常用的排序算法，按照时间复杂度的分类方式，分为时间复杂度为 `O(n^2)` 的算法，`O(nlogn)` 的算法和 `O(n)` 的算法依次讲解。\n\n<!-- more -->\n\n## 时间复杂度为 O(n^2) 的算法\n\n常见的时间复杂度为 `O(n^2)` 的算法有冒泡排序，选择排序以及插入排序。\n\n### 冒泡排序\n\n首先是第一个数和第二个数进行比较，谁大谁在后面，接着第二个数和第三个数进行比较，谁大谁在后面。以此类推，经过一轮比较下来最大的数就沉到了最后一位。将数组范围缩小到 0-N-1，再经历一轮第二大的数就在倒数第二的位置。以此类推，当数组范围只剩一个数时，数组就变得有序了。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/BubbleSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/BubbleSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif'>图片来源</a></figcaption></figure>\n\n### 选择排序\n\n首先在整个数组中选出最小的数放在最前面，接着在剩下的数组中选出最小的数放在第二个位置。以此类推，当剩下的数组只剩一个数时，整个数组就变得有序了。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/SelectSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/SelectSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif'>图片来源</a></figcaption></figure>\n\n### 插入排序\n\n首先将第二个位置和第一个位置的数进行比较，谁小谁在前。第三个位置上的数和第一、二个位置上的数比较，插入合适的位置。第四个位置上的数和第一、二、三个位置上的数比较，插入合适的位置。以此类推，当安顿好了数组的最后一个数，整个数组也变得有序了。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/InsertSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/InsertSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif'>图片来源</a></figcaption></figure>\n\n## 时间复杂度为 O(nlogn) 的算法\n\n常见的时间复杂度为 `O(nlogn)` 的算法有归并排序、快速排序、堆排序以及希尔排序。\n\n### 归并排序\n\n首先将数组中的每一个数看作长度为 1 的有序序列，然后把相邻的有序序列进行合并操作，得到最大长度为 2 的有序序列。接着再把相邻序列进行合并，得到\b最大程度为 4 的有序序列。以此类推，直到数组中的所有数合并成一个有序序列。\n\n所以归并排序的思想在于**将两两有序序列合并成一个有序序列**。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/MergeSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/MergeSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif'>图片来源</a></figcaption></figure>\n\n### 快速排序\n\n首先在数组中随机选一个作为基准数(一般选择中点位置的数)，接着将数组中小于等于基准数的放到数组左边，大于基准数的放到数组右边，使得整个数组整体有序。然后再对左右两边分别递归调用上述过程，从而使整个数组有序。\n\n[JavaScript 代码](https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/QuickSort.js), [Python 代码](https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/QuickSort.py)\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif'>图片来源</a></figcaption></figure>\n\n### 堆排序\n\n首先将数组中的 N 个数建成一个大小为 N 的大根堆，堆顶是所有元素中的最大值，将堆顶元素与堆的最后一个元素进行交换，将最大值脱离堆并作为有序部分放在数组的末尾。接着调整大根堆，将剩下元素的最大值放在堆顶然后脱离堆，加入有序部分。以此类推，当堆只剩下一个元素时，整个数组就有序了。\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif\" alt=\"可视化过程\" /><figcaption><a href='https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif'>图片来源</a></figcaption></figure>\n\n### 希尔排序\n\n希尔排序是插入排序的改良版。插入排序的步长是 1，希尔排序的步长是从大到小逐渐调整的。\n\n初始的步长需要我们来制定，比如 `6 5 3 1 8 7 2 4` 这个数组，我们选择初始步长为 3，那么 `6 5 3` 这前三个数可以暂不做调整。接着从 1 开始向前跳三位，与 6 进行比较，进而交换位置，再往前跳三位由于越界了所以不作调整了。然后看 8 这位数，向前跳三位与 5 比较，由于 8 > 5 所以不做调整。以此调整完整个数组，再修改步长为 2 和 1 再分别对数组做调整。\n\n希尔排序的时间复杂度高低完全取决于步长的选择，步长选择越优那么它的时间复杂度越低，反之时间复杂度就越高。\n\n## 时间复杂度为 O(n) 的算法\n\n时间复杂度为 `O(n)` 的算法都不是基于比较的思想，而是基于[桶排序](https://zh.wikipedia.org/zh-hant/%E6%A1%B6%E6%8E%92%E5%BA%8F)的思想。常见的有计数排序和基数排序。\n\n### 计数排序\n\n详见[计数排序](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)\n\n### 基数排序\n\n详见[基数排序](https://zh.wikipedia.org/zh-hant/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)\n\n## 总结\n\n| 名称 | 时间复杂度 | 空间复杂度 | 稳定性 |\n| --- | :---: | :---: | :---: |\n| 冒泡排序 | `O(n^2)` | `O(1)` | 稳定 |\n| 选择排序 | `O(n^2)` | `O(1)` | 不稳定 |\n| 插入排序 | `O(n^2)` | `O(1)`| 稳定 |\n| 归并排序 | `O(n*logn)` | `O(n)`| 稳定 |\n| 快速排序 | `O(n*logn)` | `O(logn)` ~ `O(n)` | 不稳定 |\n| 堆排序 | `O(n*logn)` | `O(1)` | 不稳定 |\n| 希尔排序 | `O(n*logn)` | `O(1)` | 不稳定 |\n| 计数排序 | `O(n)` | `O(m)` | 稳定 |\n| 基数排序 | `O(n)` | `O(m)` | 稳定 |\n\n**Notes：**\n\n- 计数排序与基数排序中的空间复杂度 `O(m)` 中的 m 指的是桶的数量。\n- 稳定性：指相同值的元素在排序前和排序后的相对次序是否保持不变。\n- 桶排序虽然时间复杂度高，但可以理解为是一种空间换时间的思想。当数据量很大时，需要准备的桶也就越多，会一定程序造成空间的浪费。因此具有很大的局限性。\n- 快速排序之所以叫快速排序，不是因为它比堆排序、归并排序更优良，而是因为它的常量系数比较低。\n- 在工程中，并不会特定使用某一种排序，而是综合使用。比如当元素个数比较少时，会使用插入排序；当元素个数较多时，会使用快速排序。","date_unix":1539436083000,"page_url":"_posts/zh/sorting-algorithm.md"},{"file_name":"learn-node-part2.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/learn-node-part2.md","raw_content":"---\ntitle: Node 初探之垃圾回收\nlang: zh\ndate: 2018-10-10 14:55:37\ntags:\n- node\n- javascript\n---\n\n在 [V8](https://github.com/v8/v8/wiki) 中，所有 JavaScript 对象都通过堆来进行分配的。当我们在代码中声明变量时，所使用对象的内存就分配在堆中。V8 会限制堆的大小，在 64 位系统下约为 1.4GB，32 位系统下约为 0.7GB。V8 中的垃圾回收机制也是系统自动回收，无需开发者手动回收。\n\n<!-- more -->\n\n## V8 的垃圾回收机制\n\nV8 的垃圾回收策略主要基于分代式垃圾回收机制，它将内存分为新生代和老生代，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长的对象。V8 堆的大小就等于新生代所用内存空间加上老生代所用内存空间。\n\n### 新生代 Scavenge 算法\n\n新生代的对象主要通过 Scavenge 算法进行垃圾回收，Scavenge 又主要采用了 Cheney 算法。Cheney 算法是一种使用复制的方式实现的垃圾回收算法，它将堆一分为二，一个空间处于使用状态（称为 From 空间），一个空间处于闲置状态（称为 To 空间）。\n\n当我们分配内存时，会先分配到 From 空间。当开始进行垃圾回收时，也会先检查 From 空间的对象存活情况，将还存活的对象复制到 To 空间中，释放掉非存活对象。完成复制后，From 空间和 To 空间角色互换，即保持一个在使用中一个在闲置中的状态。\n\nScavenge 是一种空间换时间的算法，它的缺点是只能使用堆内存的一半，但它很适合使用于对象生命周期短的场景，因为这种场景的存活对象少，每次复制的时间快。\n\n### 老生代 Mark-Sweep 和 Mark-Compact 算法\n\n当一个对象经过多次复制后依然属于存活对象，那么它就将被“晋升”到老生代。另外，如果发现 To 空间的内存占比达到了 25%，会直接将对象移到老生代。因为 To 空间下一次将成为 From 空间，内存占比太高不利于后续的内存分配。\n\nMark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。在标记阶段将遍历堆里的对象，标记存活的对象，在清除阶段则清除未被标记的对象。\n\nMark-Sweep 存在的问题是导致内存碎片化，因为在一次标记清除结束后内存空间可能会变得不连续。这对后期分配大内存将产生影响。\n\nMark-Compact 是标记整理的意思，是为了解决 Mark-Sweep 遗留的内存碎片化问题，它在标记完对象后将存活的对象移动到一端，只清理另一端的死亡对象。\n\n在 V8 中，主要使用 Mark-Sweep，在空间不足以对新生代中晋升过来的对象进行分配时才使用 Mark-Compact。\n\n### 对于垃圾回收的改进\n\n由于上述三种算法都需要暂停应用逻辑来执行垃圾回收，这种行为称为**全停顿**。在新生代由于默认配置比较小，因此全停顿对此影响不大，但对于配置较大的老生代来说，标记清理整理造成的停顿时间较长，因此 V8 改进了标记动作来缩小全停顿的时间。\n\nV8 将原本一口气完成标记的动作改为了增量标记，即拆分为许多小“步进”，每做完一“步进”就让应用逻辑执行一会儿，如此交替执行直到标记阶段完成。\n\n同时 V8 也引入了延迟清理和增量式整理动作来降低全停顿的时间。\n\n## 内存泄漏\n\n当应当被会收的对象出现意外没有被回收时，将会出现内存泄漏。一般在 Node 中出现内存泄漏的原因有以下几个：\n\n- 缓存的无限制使用\n- 队列消费不及时\n- 作用域未释放\n\n缓存虽然能够帮助我们提高访问效率，但过度使用缓存将使得对象常驻老年代，不得被回收。因此应该使用完善的带有过期策略的缓存，或者直接使用进程外的缓存，比如 [Redis](https://redis.io/) 和 [Memcached](https://memcached.org/)。\n\n在 Node 中的事件循环中，依赖生产者/消费者模型，会经常使用队列作为中间产物，如果队列的取用不及时，那么会造成内存泄漏。因此较大型的应用应该监控队列的使用情况，一旦堆积则报警通知。\n\n闭包的使用能够帮助我们快捷地从外部作用域访问内部作用域的变量，但这也带来变量不能及时释放的危险。因此应该适当使用闭包。同时，全局作用域中的变量通常伴随着程序退出而被释放，因此可以手动赋值来消除变量引用。","title":"Node 初探之垃圾回收","lang":"zh","date":"2018-10-10T06:55:37.000Z","tags":["node","javascript"],"_content":"\n在 [V8](https://github.com/v8/v8/wiki) 中，所有 JavaScript 对象都通过堆来进行分配的。当我们在代码中声明变量时，所使用对象的内存就分配在堆中。V8 会限制堆的大小，在 64 位系统下约为 1.4GB，32 位系统下约为 0.7GB。V8 中的垃圾回收机制也是系统自动回收，无需开发者手动回收。\n\n<!-- more -->\n\n## V8 的垃圾回收机制\n\nV8 的垃圾回收策略主要基于分代式垃圾回收机制，它将内存分为新生代和老生代，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长的对象。V8 堆的大小就等于新生代所用内存空间加上老生代所用内存空间。\n\n### 新生代 Scavenge 算法\n\n新生代的对象主要通过 Scavenge 算法进行垃圾回收，Scavenge 又主要采用了 Cheney 算法。Cheney 算法是一种使用复制的方式实现的垃圾回收算法，它将堆一分为二，一个空间处于使用状态（称为 From 空间），一个空间处于闲置状态（称为 To 空间）。\n\n当我们分配内存时，会先分配到 From 空间。当开始进行垃圾回收时，也会先检查 From 空间的对象存活情况，将还存活的对象复制到 To 空间中，释放掉非存活对象。完成复制后，From 空间和 To 空间角色互换，即保持一个在使用中一个在闲置中的状态。\n\nScavenge 是一种空间换时间的算法，它的缺点是只能使用堆内存的一半，但它很适合使用于对象生命周期短的场景，因为这种场景的存活对象少，每次复制的时间快。\n\n### 老生代 Mark-Sweep 和 Mark-Compact 算法\n\n当一个对象经过多次复制后依然属于存活对象，那么它就将被“晋升”到老生代。另外，如果发现 To 空间的内存占比达到了 25%，会直接将对象移到老生代。因为 To 空间下一次将成为 From 空间，内存占比太高不利于后续的内存分配。\n\nMark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。在标记阶段将遍历堆里的对象，标记存活的对象，在清除阶段则清除未被标记的对象。\n\nMark-Sweep 存在的问题是导致内存碎片化，因为在一次标记清除结束后内存空间可能会变得不连续。这对后期分配大内存将产生影响。\n\nMark-Compact 是标记整理的意思，是为了解决 Mark-Sweep 遗留的内存碎片化问题，它在标记完对象后将存活的对象移动到一端，只清理另一端的死亡对象。\n\n在 V8 中，主要使用 Mark-Sweep，在空间不足以对新生代中晋升过来的对象进行分配时才使用 Mark-Compact。\n\n### 对于垃圾回收的改进\n\n由于上述三种算法都需要暂停应用逻辑来执行垃圾回收，这种行为称为**全停顿**。在新生代由于默认配置比较小，因此全停顿对此影响不大，但对于配置较大的老生代来说，标记清理整理造成的停顿时间较长，因此 V8 改进了标记动作来缩小全停顿的时间。\n\nV8 将原本一口气完成标记的动作改为了增量标记，即拆分为许多小“步进”，每做完一“步进”就让应用逻辑执行一会儿，如此交替执行直到标记阶段完成。\n\n同时 V8 也引入了延迟清理和增量式整理动作来降低全停顿的时间。\n\n## 内存泄漏\n\n当应当被会收的对象出现意外没有被回收时，将会出现内存泄漏。一般在 Node 中出现内存泄漏的原因有以下几个：\n\n- 缓存的无限制使用\n- 队列消费不及时\n- 作用域未释放\n\n缓存虽然能够帮助我们提高访问效率，但过度使用缓存将使得对象常驻老年代，不得被回收。因此应该使用完善的带有过期策略的缓存，或者直接使用进程外的缓存，比如 [Redis](https://redis.io/) 和 [Memcached](https://memcached.org/)。\n\n在 Node 中的事件循环中，依赖生产者/消费者模型，会经常使用队列作为中间产物，如果队列的取用不及时，那么会造成内存泄漏。因此较大型的应用应该监控队列的使用情况，一旦堆积则报警通知。\n\n闭包的使用能够帮助我们快捷地从外部作用域访问内部作用域的变量，但这也带来变量不能及时释放的危险。因此应该适当使用闭包。同时，全局作用域中的变量通常伴随着程序退出而被释放，因此可以手动赋值来消除变量引用。","date_unix":1539154537000,"page_url":"_posts/zh/learn-node-part2.md"},{"file_name":"learn-node-part1.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/learn-node-part1.md","raw_content":"---\ntitle: Node 初探之异步\nlang: zh\ndate: 2018-10-09 21:13:19\ntags:\n- node\n- javascript\n---\n\n异步是指*现在*运行的程序和*将来*运行的程序中有一段时间间隙，如何处理这段时间间隙就是异步编程的核心。最简单的方法是使用回调函数。\n\n<!-- more -->\n\nNode 的特点有异步 IO、事件循环与回调函数和单线程。Node 的使用场景有 I/O 密集型应用、CPU 密集型应用和分布式应用。Nginx 与 Node 都是异步 I/O、事件驱动的设计理念，它们的区别是 Nginx 具备面向客户端管理连接的强大能力，它的背后依然受限于各种同步方式的编程语言。\n\n## 异步 I/O\n\n以读取文件为例，\n\n``` js\nvar fs = require('fs');\n\nfs.readFile('/path', function(err, file) {\n  console.log('读取文件完成');\n});\nconsole.log(‘发起读取文件’);\n```\n\n“发起读取文件”是在“读取文件完成”之前输出的，而“读取文件完成”什么时候输出取决于读取文件的异步调用何时结束。“发起读取文件”可以理解为*现在*运行的程序，“读取文件完成”理解为*将来*运行的程序。\n\n即异步调用为，应用程序发起了请求之后可以继续执行任务，当请求处理完毕返回数据后触发回调函数处理数据。\n\n![异步调用](quiver-image-url/180903697EEB5E579BC9E86B99BFA2A0.jpg =658x591)\n\n使用异步的原因：\n\n- 用户体验：如果使用同步请求，那么获取资源是串行的，前面的资源获取会阻塞后面的资源获取。\n- 资源分配：主流的执行任务的方式有多线程并行执行和单线程串行执行。这种方式都有其致命弊端，Node 在其中作出取舍。\n\n多线程的代价在于创建线程和执行线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步等问题。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率。\n\n单线程的顺序执行符合思考习惯，易于表达。但串行执行的缺点在于性能，任意一个略慢的任务都会阻塞后续任务的执行。在计算机资源中，通常 I/O 和 CPU 计算之间可以并行进行，但同步编程使得只能串行执行，因此资源不能得到合理利用。\n\nNode 在两者中作出了调整：利用单线程，远离多线程死锁、状态同步问题；利用异步 I/O，让单线程远离阻塞，以更好地使用 CPU。为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中的 Web Worker 的子进程，child_process，该子进程可以通过工作进程高效地利用 CPU 和 I/O。\n\n**阻塞与非阻塞**\n操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。\n\n在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才返回结果，阻塞 I/O 的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。\n\n阻塞 I/O 造成 CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用。\n\n非阻塞 I/O 与阻塞 I/O 的区别是调用之后立即返回。但非阻塞 I/O 也有缺点，那就是立即返回的数据并不是业务层期望的数据，而是当前调用的状态。因此为了获取完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成，这种技术叫**轮询**。\n\n### Node 中的异步 I/O\n\nJavaScript 引擎并不是独立存在的，而是运行在宿主环境中，比如浏览器或者 Node。JavaScript 引擎自身没有时间概念，而是按需执行 JavaScript 代码。而事件的调度(即异步的执行)是由宿主环境完成的。在 Node 中完成整个异步 I/O 环节的有**事件循环**、**观察者**和**请求对象**等。\n\n**事件循环**\n事件循环是一种机制，用来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎。事件循环的大体过程如下。\n\n在 Node 进程启动时，Node 会创建一个类似于 `while(true)` 的循环，在这个循环中执行的过程为查看是否有事件待处理，如果有就取出事件及回调函数，如果还存在关联的回调函数，就执行它们。然后进入下个循环，直到没有事件处理了就退出循环。\n\n可以用一段伪代码表示上述行为：\n\n``` js\n// 事件队列\nvar eventLoop = []; // queue\n// 事件(回调函数)\nvar event;\n\nwhile (true) {\n  if (eventLoop.length > 0) {\n    // 读取下一个事件\n    event = eventLoop.shift();\n    // 执行事件\n    try {\n      event();\n    } catch(err) {\n      reportError(err);\n    }\n  }\n}\n```\n\n![事件循环](quiver-image-url/B8B27ABE4E184FF15C014A4AA595B0C8.jpg =611x569)\n\n**观察者**\n观察者的作用在于在每一次循环中判断是否还有事件需要处理。每个事件循环中有一个或多个观察者，而判断是否有事件处理的过程就是向这些观察者询问是否有要处理的事件。浏览器也是类似的机制，事件可能来自于用户的点击，这些产生的事件都有对应的观察者。\n\n在 Node 中，这是一个典型的[生产者/消费者模型](https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98)，事件是生产者，可能来自于异步 I/O，网络请求等，这些事件被传递到观察者那边，事件循环是消费者，它从观察者手中取出事件并执行回调函数。\n\n**请求对象**\n在 Node 中，回调函数不需要我们自己调用，而是通过请求对象来帮助我们完成调用。\n\n主要的过程总结为，程序发起异步调用，将执行方法，请求参数和回调函数等封装到请求对象中，接着将请求对象放入 I/O 线程池中等待执行。到这里，JavaScript 的调用返回，JavaScript 线程可以继续执行后续任务。\n\n当线程池中有可用线程时，将执行请求对象中的方法，并将执行后的结果也放在请求对象中，至此通知线程池执行完毕，将线程归还线程池。\n\n接下来就是执行回调函数了。执行完成的方法被传到观察者那里，事件循环从观察者手中取出可用的请求对象，拿出回调函数和结果用于执行。于是乎，JavaScript 中传入的回调函数得到了执行。\n\n### Node 中的非 I/O 异步 API\n\n与 I/O 无关的异步 API 比如：setTimeout(), setInterval(), setImmediate(), process.nextTick()。\n\n`setTimeout()` 和 `setInterval()` 与浏览器中的 API 一致，分别用于单次和多次定时执行的任务。它们的实现原理和异步 I/O 类似，只是不需要 I/O 线程池的参与。\n\n`setTimeout()` 创建的定时器将被插入到定时器观察者内部的一颗红黑树中，每一次事件循环执行时，将从该树中取出定时器对象，检查是否已经超时，如果超时则形成一个事件放入事件循环队列中，等待宿主环境（浏览器、Node）执行它的回调函数。\n\n如果队列中已经存在很多项目，那么 `setTimeout()` 的回调就将排队等候，等到执行时可能已经过了定时的时间。所以它可能存在精度不高的情况。\n\n`setInterval()` 和上述过程类似，区别在于重复检测和执行。\n\n`process.nextTick()` 常用于立即异步执行一个任务。相比于使用 `setTimeout(callback, 0)` 的方式，显得更轻量一些。后者需要动用红黑树，创建定时器对象和迭代等操作，并且存在定时器不准确的问题，而前者仅仅将回调函数放入队列，在下一轮事件循环中从队列取出执行即可。\n\n`setImmediate()` 和 `process.nextTick()` 类似，首要区别在于 `process.nextTick()` 的回调函数执行优先级高于 `setImmediate()`。可以用下面的例子验证：\n\n``` js\nprocess.nextTick(function() {\n  console.log('nextTick 延迟执行');\n});\n\nsetImmediate(function() {\n  console.log('setImmediate 延迟执行');\n});\nconsole.log('正常执行');\n\n// 执行结果\n// 正常执行\n// nextTick 延迟执行\n// setImmediate 延迟执行\n```\n\n第二个区别在于 `process.nextTick()` 的回调函数保存在一个数组中，`setImmediate()` 则保存在链表中。\n\n## 异步编程\n\n异步编程的主要解决方法有三种：事件发布/订阅模式、Promise/Deferred 模式和流程控制库。","title":"Node 初探之异步","lang":"zh","date":"2018-10-09T13:13:19.000Z","tags":["node","javascript"],"_content":"\n异步是指*现在*运行的程序和*将来*运行的程序中有一段时间间隙，如何处理这段时间间隙就是异步编程的核心。最简单的方法是使用回调函数。\n\n<!-- more -->\n\nNode 的特点有异步 IO、事件循环与回调函数和单线程。Node 的使用场景有 I/O 密集型应用、CPU 密集型应用和分布式应用。Nginx 与 Node 都是异步 I/O、事件驱动的设计理念，它们的区别是 Nginx 具备面向客户端管理连接的强大能力，它的背后依然受限于各种同步方式的编程语言。\n\n## 异步 I/O\n\n以读取文件为例，\n\n``` js\nvar fs = require('fs');\n\nfs.readFile('/path', function(err, file) {\n  console.log('读取文件完成');\n});\nconsole.log(‘发起读取文件’);\n```\n\n“发起读取文件”是在“读取文件完成”之前输出的，而“读取文件完成”什么时候输出取决于读取文件的异步调用何时结束。“发起读取文件”可以理解为*现在*运行的程序，“读取文件完成”理解为*将来*运行的程序。\n\n即异步调用为，应用程序发起了请求之后可以继续执行任务，当请求处理完毕返回数据后触发回调函数处理数据。\n\n![异步调用](quiver-image-url/180903697EEB5E579BC9E86B99BFA2A0.jpg =658x591)\n\n使用异步的原因：\n\n- 用户体验：如果使用同步请求，那么获取资源是串行的，前面的资源获取会阻塞后面的资源获取。\n- 资源分配：主流的执行任务的方式有多线程并行执行和单线程串行执行。这种方式都有其致命弊端，Node 在其中作出取舍。\n\n多线程的代价在于创建线程和执行线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步等问题。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率。\n\n单线程的顺序执行符合思考习惯，易于表达。但串行执行的缺点在于性能，任意一个略慢的任务都会阻塞后续任务的执行。在计算机资源中，通常 I/O 和 CPU 计算之间可以并行进行，但同步编程使得只能串行执行，因此资源不能得到合理利用。\n\nNode 在两者中作出了调整：利用单线程，远离多线程死锁、状态同步问题；利用异步 I/O，让单线程远离阻塞，以更好地使用 CPU。为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中的 Web Worker 的子进程，child_process，该子进程可以通过工作进程高效地利用 CPU 和 I/O。\n\n**阻塞与非阻塞**\n操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。\n\n在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才返回结果，阻塞 I/O 的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。\n\n阻塞 I/O 造成 CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用。\n\n非阻塞 I/O 与阻塞 I/O 的区别是调用之后立即返回。但非阻塞 I/O 也有缺点，那就是立即返回的数据并不是业务层期望的数据，而是当前调用的状态。因此为了获取完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成，这种技术叫**轮询**。\n\n### Node 中的异步 I/O\n\nJavaScript 引擎并不是独立存在的，而是运行在宿主环境中，比如浏览器或者 Node。JavaScript 引擎自身没有时间概念，而是按需执行 JavaScript 代码。而事件的调度(即异步的执行)是由宿主环境完成的。在 Node 中完成整个异步 I/O 环节的有**事件循环**、**观察者**和**请求对象**等。\n\n**事件循环**\n事件循环是一种机制，用来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎。事件循环的大体过程如下。\n\n在 Node 进程启动时，Node 会创建一个类似于 `while(true)` 的循环，在这个循环中执行的过程为查看是否有事件待处理，如果有就取出事件及回调函数，如果还存在关联的回调函数，就执行它们。然后进入下个循环，直到没有事件处理了就退出循环。\n\n可以用一段伪代码表示上述行为：\n\n``` js\n// 事件队列\nvar eventLoop = []; // queue\n// 事件(回调函数)\nvar event;\n\nwhile (true) {\n  if (eventLoop.length > 0) {\n    // 读取下一个事件\n    event = eventLoop.shift();\n    // 执行事件\n    try {\n      event();\n    } catch(err) {\n      reportError(err);\n    }\n  }\n}\n```\n\n![事件循环](quiver-image-url/B8B27ABE4E184FF15C014A4AA595B0C8.jpg =611x569)\n\n**观察者**\n观察者的作用在于在每一次循环中判断是否还有事件需要处理。每个事件循环中有一个或多个观察者，而判断是否有事件处理的过程就是向这些观察者询问是否有要处理的事件。浏览器也是类似的机制，事件可能来自于用户的点击，这些产生的事件都有对应的观察者。\n\n在 Node 中，这是一个典型的[生产者/消费者模型](https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98)，事件是生产者，可能来自于异步 I/O，网络请求等，这些事件被传递到观察者那边，事件循环是消费者，它从观察者手中取出事件并执行回调函数。\n\n**请求对象**\n在 Node 中，回调函数不需要我们自己调用，而是通过请求对象来帮助我们完成调用。\n\n主要的过程总结为，程序发起异步调用，将执行方法，请求参数和回调函数等封装到请求对象中，接着将请求对象放入 I/O 线程池中等待执行。到这里，JavaScript 的调用返回，JavaScript 线程可以继续执行后续任务。\n\n当线程池中有可用线程时，将执行请求对象中的方法，并将执行后的结果也放在请求对象中，至此通知线程池执行完毕，将线程归还线程池。\n\n接下来就是执行回调函数了。执行完成的方法被传到观察者那里，事件循环从观察者手中取出可用的请求对象，拿出回调函数和结果用于执行。于是乎，JavaScript 中传入的回调函数得到了执行。\n\n### Node 中的非 I/O 异步 API\n\n与 I/O 无关的异步 API 比如：setTimeout(), setInterval(), setImmediate(), process.nextTick()。\n\n`setTimeout()` 和 `setInterval()` 与浏览器中的 API 一致，分别用于单次和多次定时执行的任务。它们的实现原理和异步 I/O 类似，只是不需要 I/O 线程池的参与。\n\n`setTimeout()` 创建的定时器将被插入到定时器观察者内部的一颗红黑树中，每一次事件循环执行时，将从该树中取出定时器对象，检查是否已经超时，如果超时则形成一个事件放入事件循环队列中，等待宿主环境（浏览器、Node）执行它的回调函数。\n\n如果队列中已经存在很多项目，那么 `setTimeout()` 的回调就将排队等候，等到执行时可能已经过了定时的时间。所以它可能存在精度不高的情况。\n\n`setInterval()` 和上述过程类似，区别在于重复检测和执行。\n\n`process.nextTick()` 常用于立即异步执行一个任务。相比于使用 `setTimeout(callback, 0)` 的方式，显得更轻量一些。后者需要动用红黑树，创建定时器对象和迭代等操作，并且存在定时器不准确的问题，而前者仅仅将回调函数放入队列，在下一轮事件循环中从队列取出执行即可。\n\n`setImmediate()` 和 `process.nextTick()` 类似，首要区别在于 `process.nextTick()` 的回调函数执行优先级高于 `setImmediate()`。可以用下面的例子验证：\n\n``` js\nprocess.nextTick(function() {\n  console.log('nextTick 延迟执行');\n});\n\nsetImmediate(function() {\n  console.log('setImmediate 延迟执行');\n});\nconsole.log('正常执行');\n\n// 执行结果\n// 正常执行\n// nextTick 延迟执行\n// setImmediate 延迟执行\n```\n\n第二个区别在于 `process.nextTick()` 的回调函数保存在一个数组中，`setImmediate()` 则保存在链表中。\n\n## 异步编程\n\n异步编程的主要解决方法有三种：事件发布/订阅模式、Promise/Deferred 模式和流程控制库。","date_unix":1539090799000,"page_url":"_posts/zh/learn-node-part1.md"},{"file_name":"network-notes-part2.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/network-notes-part2.md","raw_content":"---\ntitle: 网络基础知识备忘录(二)\nlang: zh\ndate: 2018-10-08 19:59:34\ncover: /assets/4.jpg\ntags:\n- network\n---\n\n> 对于我来说网络知识是属于比较抽象的部分，很多东西不记录下来很快就会忘记。所以有了这个网络基础知识的备忘录，这是第二部分，[第一部分见这里](https://kexin-li.github.io/zh/2018/09/17/network-notes-part1/) :)\n\n<!-- more -->\n\n**UPDATE 2018-10-18:**\n总结了一张图~\n<figure><img src=\"/assets/web-performance.jpg\" alt=\"web performance\"/><figcaption><a href='https://my.mindnode.com/SGq4XphJ6AHUMz4z7pXqpQbFt9T2NSyXaDszpJqr'>线上地址</a></figcaption></figure>\n\n## HTTP 的缺点\n\n1. 通信使用明文（不加密），内容可能会被窃听。\n2. 不验证通信方的身份，因此有可能已遭篡改。\n3. 无法证明报文的完整性，所以有可能已遭篡改。\n\n**通信使用明文**\nHTTP 报文使用明文方式发送，这导致了在某个环节中会有被窃听的风险。因为互联网上任何角落的通信内容都存在被窃听的风险。而窃听的手段就是收集在互联网上流动的数据包就行了，再根据某些解析工具（比如抓包工具，嗅探器工具）来解析这些数据包。\n\n因此为了防止被窃听，可以使用加密技术来保护信息。加密的对象可以是通信的加密和内容的加密。\n\n将通信加密即通过 HTTP 协议和 SSL(Secure Socket Layer, 安全套接字) 或 TLS(Transport Layer Security, 安全传输层协议) 的组合使用来加密 HTTP 的通信内容。其中与 SSL 组合使用的 HTTP 被称为 HTTPS。\n\n而将内容加密是客户端先对 HTTP 报文中所含的内容（报文主体）进行加密处理，再发送请求。当然，为了做到有效加密机制，前提是要求客户端和服务端同时具备加密和解密机制。并且对内容加密不同于对整条通信线路加密，因此内容还是有被篡改的风险。\n\n**不验证通信方的身份**\n由于 HTTP 协议在通信时，不存在确认通信方的步骤，因此任何人都可以发起请求，服务器只要接收到请求，不管是谁都会返回一个响应。这就造成了请求或响应有被篡改的风险。\n\n使用 SSL 不仅能提供加密处理，也能提供证书，用以验证对方是否可信任。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。\n\n**无法证明报文的完整性**\nHTTP 协议无法确认报文的完整性，也就是说无法确认到达服务器的请求是否和客户端发送的请求一致，也无法确认客户端收到的响应是否和服务端返回的响应一致，它们都可能遭篡改。类似这样的，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-in-the-Middle attack, MITM)。\n\n可以使用 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法来保证报文的完整性。但它们也不是百分百能保证，比如如果 MD5 本身就被改写的情况。\n\n以上如此多的弊端，真的有必要使用 HTTPS 了。\n\n## HTTPS\n\n`HTTPS = HTTP + 加密 + 认证 + 完整性保护`。 HTTPS 并非是一个新协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。通常情况 HTTP 直接和 TCP 通信。当使用 SSL 时，HTTP 先和 SSL 通信，再由 SSL 和 TCP 通信。简言之，HTTPS 是披着 SSL 外壳的 HTTP。\n\n### 加密技术\n\n在近代的加密方法中，加密算法通常是公开的，而密钥是保密的。加密和解密都会用到密钥。其中加密和解密使用同一把密钥的方式称为共享密钥加密。以共享密钥加密方式加密时必须也要把密钥也发送给对方。但密钥的发送也有被窃听的风险，并且如果密钥能安全发送那么数据应该也能安全发送吧。所以这是一个显得有点“矛盾”的加密方式。\n\n加密和解密使用不同的密钥称为公开密钥方式。其中一把为公开密钥，一把为私有密钥。顾名思义，公开密钥可以随意发布，而私有密钥不能让任何人知道。在发送端使用公开密钥进行加密处理，接收端使用自己的私有密钥进行解密。\n\nHTTPS 采用共享密钥加密和公开密钥加密的混合加密机制，这是因为公开密钥加密比共享密钥加密处理速度慢很多。在确保安全的前提下，则采用共享密钥加密来加快处理速度。\n\n### SSL\n\nSSL 采用公开密钥加密（Public-key cryptography）的加密处理方式。\n\n当使用 SSL 时，它的处理速度会变慢。也就是当使用 HTTPS 时，会比使用 HTTP 慢很多。原因是 HTTPS 不仅需要做服务器、客户端双方的加密及解密处理，这会消耗 CPU 及内存等硬件资源，而且需要做 SSL 通信处理，因此通信时间会延长。\n\n针对速度慢这一问题，我们会使用 SSL 加速器这种硬件来改善问题。\n\n## Web 的攻击技术\n\n在 HTTP 请求报文内加载攻击代码，就能对 Web 应用发起攻击。通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。\n\n对 Web 的攻击模式有两种：主动攻击和被动攻击。\n\n**主动攻击**\n主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者能够访问到那些资源。最具代表性的主动攻击是** SQL 注入攻击**和** OS 命令注入攻击**。\n\n**被动攻击**\n被动攻击（passive attack）是指利用圈套策略执行攻击代码。在被动攻击过程中，攻击者不直接对目标 Web 应用发起攻击，而是诱发用户触发圈套来执行攻击代码。最具代表性的被动攻击是跨站脚本攻击（Cross-Site Scripting, XSS）和跨站点请求伪造。","title":"网络基础知识备忘录(二)","lang":"zh","date":"2018-10-08T11:59:34.000Z","cover":"/assets/4.jpg","tags":["network"],"_content":"\n> 对于我来说网络知识是属于比较抽象的部分，很多东西不记录下来很快就会忘记。所以有了这个网络基础知识的备忘录，这是第二部分，[第一部分见这里](https://kexin-li.github.io/zh/2018/09/17/network-notes-part1/) :)\n\n<!-- more -->\n\n**UPDATE 2018-10-18:**\n总结了一张图~\n<figure><img src=\"/assets/web-performance.jpg\" alt=\"web performance\"/><figcaption><a href='https://my.mindnode.com/SGq4XphJ6AHUMz4z7pXqpQbFt9T2NSyXaDszpJqr'>线上地址</a></figcaption></figure>\n\n## HTTP 的缺点\n\n1. 通信使用明文（不加密），内容可能会被窃听。\n2. 不验证通信方的身份，因此有可能已遭篡改。\n3. 无法证明报文的完整性，所以有可能已遭篡改。\n\n**通信使用明文**\nHTTP 报文使用明文方式发送，这导致了在某个环节中会有被窃听的风险。因为互联网上任何角落的通信内容都存在被窃听的风险。而窃听的手段就是收集在互联网上流动的数据包就行了，再根据某些解析工具（比如抓包工具，嗅探器工具）来解析这些数据包。\n\n因此为了防止被窃听，可以使用加密技术来保护信息。加密的对象可以是通信的加密和内容的加密。\n\n将通信加密即通过 HTTP 协议和 SSL(Secure Socket Layer, 安全套接字) 或 TLS(Transport Layer Security, 安全传输层协议) 的组合使用来加密 HTTP 的通信内容。其中与 SSL 组合使用的 HTTP 被称为 HTTPS。\n\n而将内容加密是客户端先对 HTTP 报文中所含的内容（报文主体）进行加密处理，再发送请求。当然，为了做到有效加密机制，前提是要求客户端和服务端同时具备加密和解密机制。并且对内容加密不同于对整条通信线路加密，因此内容还是有被篡改的风险。\n\n**不验证通信方的身份**\n由于 HTTP 协议在通信时，不存在确认通信方的步骤，因此任何人都可以发起请求，服务器只要接收到请求，不管是谁都会返回一个响应。这就造成了请求或响应有被篡改的风险。\n\n使用 SSL 不仅能提供加密处理，也能提供证书，用以验证对方是否可信任。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。\n\n**无法证明报文的完整性**\nHTTP 协议无法确认报文的完整性，也就是说无法确认到达服务器的请求是否和客户端发送的请求一致，也无法确认客户端收到的响应是否和服务端返回的响应一致，它们都可能遭篡改。类似这样的，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-in-the-Middle attack, MITM)。\n\n可以使用 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法来保证报文的完整性。但它们也不是百分百能保证，比如如果 MD5 本身就被改写的情况。\n\n以上如此多的弊端，真的有必要使用 HTTPS 了。\n\n## HTTPS\n\n`HTTPS = HTTP + 加密 + 认证 + 完整性保护`。 HTTPS 并非是一个新协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。通常情况 HTTP 直接和 TCP 通信。当使用 SSL 时，HTTP 先和 SSL 通信，再由 SSL 和 TCP 通信。简言之，HTTPS 是披着 SSL 外壳的 HTTP。\n\n### 加密技术\n\n在近代的加密方法中，加密算法通常是公开的，而密钥是保密的。加密和解密都会用到密钥。其中加密和解密使用同一把密钥的方式称为共享密钥加密。以共享密钥加密方式加密时必须也要把密钥也发送给对方。但密钥的发送也有被窃听的风险，并且如果密钥能安全发送那么数据应该也能安全发送吧。所以这是一个显得有点“矛盾”的加密方式。\n\n加密和解密使用不同的密钥称为公开密钥方式。其中一把为公开密钥，一把为私有密钥。顾名思义，公开密钥可以随意发布，而私有密钥不能让任何人知道。在发送端使用公开密钥进行加密处理，接收端使用自己的私有密钥进行解密。\n\nHTTPS 采用共享密钥加密和公开密钥加密的混合加密机制，这是因为公开密钥加密比共享密钥加密处理速度慢很多。在确保安全的前提下，则采用共享密钥加密来加快处理速度。\n\n### SSL\n\nSSL 采用公开密钥加密（Public-key cryptography）的加密处理方式。\n\n当使用 SSL 时，它的处理速度会变慢。也就是当使用 HTTPS 时，会比使用 HTTP 慢很多。原因是 HTTPS 不仅需要做服务器、客户端双方的加密及解密处理，这会消耗 CPU 及内存等硬件资源，而且需要做 SSL 通信处理，因此通信时间会延长。\n\n针对速度慢这一问题，我们会使用 SSL 加速器这种硬件来改善问题。\n\n## Web 的攻击技术\n\n在 HTTP 请求报文内加载攻击代码，就能对 Web 应用发起攻击。通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。\n\n对 Web 的攻击模式有两种：主动攻击和被动攻击。\n\n**主动攻击**\n主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者能够访问到那些资源。最具代表性的主动攻击是** SQL 注入攻击**和** OS 命令注入攻击**。\n\n**被动攻击**\n被动攻击（passive attack）是指利用圈套策略执行攻击代码。在被动攻击过程中，攻击者不直接对目标 Web 应用发起攻击，而是诱发用户触发圈套来执行攻击代码。最具代表性的被动攻击是跨站脚本攻击（Cross-Site Scripting, XSS）和跨站点请求伪造。","date_unix":1538999974000,"page_url":"_posts/zh/network-notes-part2.md"},{"file_name":"what-is-scope-and-closures.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/what-is-scope-and-closures.md","raw_content":"---\ntitle: JavaScript 作用域与闭包\nlang: zh\ndate: 2018-09-20 20:17:08\ncover: /assets/5.jpg\ntags:\n- javascript\n---\n作用域是一套规则，它用来指导引擎如何查找到变量。所以我认为作用域主要是用来确定变量的位置，判断是否可访问到。\n\n> 作用域是引擎的另一个好朋友（还有一个是编译器），它负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。\n\n<!-- more -->\n\n作用域有两种模型：词法作用域和动态作用域。第一种是较为普遍的，JavaScript 中的作用域也属于这一种。\n\n## 词法作用域\n\n词法作用域就是定义在词法阶段的作用域，即写代码时将变量定义在哪个位置，在编译器的词法分析阶段，就根据相应的规则得到的作用域，而这个作用域就将保持不变。但也有一些函数（eval(), with）或手段能够在运行时更改作用域，但更改作用域会**导致性能下降**，所以不推荐这样做。\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/scope.png\" alt=\"Scope example\" /><figcaption>Scope 实例代码</figcaption></figure>\n\n如上图所示的一段代码，包含着三个逐级嵌套的作用域：\n\n- 全局作用域，其中只有一个[标识符](https://zh.wikipedia.org/wiki/%E6%A8%99%E8%AD%98%E7%AC%A6)：foo。\n- foo 作用域，指的是 foo 所创建的作用域，其中有三个标识符：a, b, c。\n- bar 作用域，其中有一个标识符：c。\n\nJS 引擎在查找这些标识符时，将会先从内部作用域，依此向上查找。在每一层作用域查找时找到就会退出，否则直到全局作用域。如果到了全局作用域还没找到，就会报 `ReferenceError` 的错误。\n\n在查找的过程中还需要注意两点：\n\n- 在多层嵌套的作用域中，具有“遮蔽效应”。就是说如果内层作用域与外层作用域有同样的标识符 a，那么将选用内层的 a。即：内层的标识符遮蔽了外层的。\n- JS 引擎只会查找一级标识符。比如，a, b, c。如果是 foo.bar.baz，也只会查找到 foo 为止，剩下的由对象访问规则接管对 bar 和 baz 的访问。\n\n## 函数作用域\n\n其实在词法作用域中，除了全局作用域，其余的大部分都是函数作用域。在嵌套的函数作用域中，内部作用域能访问外部变量。比如：\n\n``` js\nfunction foo(a) {\n  var b = 2;\n\n  function bar() {\n    console.log(a, b);\n  }\n\n  bar();\n}\n\nfoo(4); // 4, 2\n```\n\n在函数作用域，要注意以下两点：\n\n- “最小授权原则”。\n- 始终给函数命名。\n\n“最小授权原则”指应该最小限度的暴露必要内容。这一原则除了在代码架构上尤为重要，在决定变量处于哪一个作用域也是如此。如果我们将所有的所有的变量或函数都暴露在全局作用域，那么其他所有的嵌套作用域都可访问到这些变量或函数，可能会对这些变量或函数造成污染。因此，应该将变量声明到离使用它的地方越近越好。\n\n始终给函数命名的原因有以下几点：\n\n- 匿名函数在调试时不会显示有意义的名称。\n- 如果没有函数名，当一个函数需要递归调用自身时，只能使用已过期的 `arguments.callee` 引用。\n- 匿名函数的代码可读性很差。\n\n**立即执行函数**\n立即执行函数指不需要调用就能自动执行的函数，下面这样的函数就是立即执行函数：\n\n``` js\nvar a = 2;\n\n(function foo() {\n  var a = 3;\n  console.log(a); // 3\n})();\n\nconsole.log(a); // 2\n```\n\n<!--### 块作用域-->\n\n## 提升（Hoisting）\n\n提升是包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。\n\n**变量提升**\n变量 a 的声明虽然在赋值之后，但因为 JS 引擎会将声明首先执行，因此这段程序还是能正常运行。\n\n``` js\na = 2;\nvar a;\nconsole.log(a); // 2\n```\n\n**函数提升**\n函数 foo 的声明虽然在执行之后，但 JS 引擎会将声明提前，因此代码不会报错。变量 a 也是同理。\n\n``` js\nfoo();\nfunction foo() {\n  console.log(a); // undefined\n  var a = 2;\n}\n```\n\n**注意，函数声明会被提升，但函数表达式不会被提升。**比如下面这段代码。变量标识符 foo() 会被提升并被分配至所在作用域（全局作用域），因此不会产生 ReferenceError。此时 foo 并没有赋值，因此抛出 TypeError 异常。\n\n``` js\nfoo(); // 不是 ReferenceError，而是 TypeError\nbar(); // ReferenceError\nvar foo = function bar() {\n  // ...\n}\n```\n\n关于函数表达式与函数声明，最主要的区别就是函数表达式可以没有名称，可以作为匿名函数。其次，一个函数表达式可以被用作一个 IIFE(Immediately Invoked Function Expression，立即执行函数)。\n\n## 闭包(Closure)\n\n闭包是基于词法作用域写代码时所产生的自然结果。当函数可以在它所在词法作用域之外被执行时，就产生了闭包。比如下面这段代码：\n\n``` js\nfunction foo() {\n  var a = 2;\n  function bar() {\n    console.log(a);\n  }\n  return bar;\n}\n\nvar baz = foo();\nbaz(); // 2\n```\n\n这段代码共有三个作用域，Global, foo 和 bar 作用域。函数 `bar()` 在 foo 作用域中，它本身被当作一个值返回。接着，函数 `foo()` 的返回值函数 `bar()` 赋值给了变量 `baz`，而调用 `baz()` 就相当于调用了函数 `bar()`。这个时候函数 `bar()` 就在它原本的作用域（foo）之外的作用域（global）被执行了。这就是闭包。\n","title":"JavaScript 作用域与闭包","lang":"zh","date":"2018-09-20T12:17:08.000Z","cover":"/assets/5.jpg","tags":["javascript"],"_content":"作用域是一套规则，它用来指导引擎如何查找到变量。所以我认为作用域主要是用来确定变量的位置，判断是否可访问到。\n\n> 作用域是引擎的另一个好朋友（还有一个是编译器），它负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。\n\n<!-- more -->\n\n作用域有两种模型：词法作用域和动态作用域。第一种是较为普遍的，JavaScript 中的作用域也属于这一种。\n\n## 词法作用域\n\n词法作用域就是定义在词法阶段的作用域，即写代码时将变量定义在哪个位置，在编译器的词法分析阶段，就根据相应的规则得到的作用域，而这个作用域就将保持不变。但也有一些函数（eval(), with）或手段能够在运行时更改作用域，但更改作用域会**导致性能下降**，所以不推荐这样做。\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/scope.png\" alt=\"Scope example\" /><figcaption>Scope 实例代码</figcaption></figure>\n\n如上图所示的一段代码，包含着三个逐级嵌套的作用域：\n\n- 全局作用域，其中只有一个[标识符](https://zh.wikipedia.org/wiki/%E6%A8%99%E8%AD%98%E7%AC%A6)：foo。\n- foo 作用域，指的是 foo 所创建的作用域，其中有三个标识符：a, b, c。\n- bar 作用域，其中有一个标识符：c。\n\nJS 引擎在查找这些标识符时，将会先从内部作用域，依此向上查找。在每一层作用域查找时找到就会退出，否则直到全局作用域。如果到了全局作用域还没找到，就会报 `ReferenceError` 的错误。\n\n在查找的过程中还需要注意两点：\n\n- 在多层嵌套的作用域中，具有“遮蔽效应”。就是说如果内层作用域与外层作用域有同样的标识符 a，那么将选用内层的 a。即：内层的标识符遮蔽了外层的。\n- JS 引擎只会查找一级标识符。比如，a, b, c。如果是 foo.bar.baz，也只会查找到 foo 为止，剩下的由对象访问规则接管对 bar 和 baz 的访问。\n\n## 函数作用域\n\n其实在词法作用域中，除了全局作用域，其余的大部分都是函数作用域。在嵌套的函数作用域中，内部作用域能访问外部变量。比如：\n\n``` js\nfunction foo(a) {\n  var b = 2;\n\n  function bar() {\n    console.log(a, b);\n  }\n\n  bar();\n}\n\nfoo(4); // 4, 2\n```\n\n在函数作用域，要注意以下两点：\n\n- “最小授权原则”。\n- 始终给函数命名。\n\n“最小授权原则”指应该最小限度的暴露必要内容。这一原则除了在代码架构上尤为重要，在决定变量处于哪一个作用域也是如此。如果我们将所有的所有的变量或函数都暴露在全局作用域，那么其他所有的嵌套作用域都可访问到这些变量或函数，可能会对这些变量或函数造成污染。因此，应该将变量声明到离使用它的地方越近越好。\n\n始终给函数命名的原因有以下几点：\n\n- 匿名函数在调试时不会显示有意义的名称。\n- 如果没有函数名，当一个函数需要递归调用自身时，只能使用已过期的 `arguments.callee` 引用。\n- 匿名函数的代码可读性很差。\n\n**立即执行函数**\n立即执行函数指不需要调用就能自动执行的函数，下面这样的函数就是立即执行函数：\n\n``` js\nvar a = 2;\n\n(function foo() {\n  var a = 3;\n  console.log(a); // 3\n})();\n\nconsole.log(a); // 2\n```\n\n<!--### 块作用域-->\n\n## 提升（Hoisting）\n\n提升是包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。\n\n**变量提升**\n变量 a 的声明虽然在赋值之后，但因为 JS 引擎会将声明首先执行，因此这段程序还是能正常运行。\n\n``` js\na = 2;\nvar a;\nconsole.log(a); // 2\n```\n\n**函数提升**\n函数 foo 的声明虽然在执行之后，但 JS 引擎会将声明提前，因此代码不会报错。变量 a 也是同理。\n\n``` js\nfoo();\nfunction foo() {\n  console.log(a); // undefined\n  var a = 2;\n}\n```\n\n**注意，函数声明会被提升，但函数表达式不会被提升。**比如下面这段代码。变量标识符 foo() 会被提升并被分配至所在作用域（全局作用域），因此不会产生 ReferenceError。此时 foo 并没有赋值，因此抛出 TypeError 异常。\n\n``` js\nfoo(); // 不是 ReferenceError，而是 TypeError\nbar(); // ReferenceError\nvar foo = function bar() {\n  // ...\n}\n```\n\n关于函数表达式与函数声明，最主要的区别就是函数表达式可以没有名称，可以作为匿名函数。其次，一个函数表达式可以被用作一个 IIFE(Immediately Invoked Function Expression，立即执行函数)。\n\n## 闭包(Closure)\n\n闭包是基于词法作用域写代码时所产生的自然结果。当函数可以在它所在词法作用域之外被执行时，就产生了闭包。比如下面这段代码：\n\n``` js\nfunction foo() {\n  var a = 2;\n  function bar() {\n    console.log(a);\n  }\n  return bar;\n}\n\nvar baz = foo();\nbaz(); // 2\n```\n\n这段代码共有三个作用域，Global, foo 和 bar 作用域。函数 `bar()` 在 foo 作用域中，它本身被当作一个值返回。接着，函数 `foo()` 的返回值函数 `bar()` 赋值给了变量 `baz`，而调用 `baz()` 就相当于调用了函数 `bar()`。这个时候函数 `bar()` 就在它原本的作用域（foo）之外的作用域（global）被执行了。这就是闭包。\n","date_unix":1537445828000,"page_url":"_posts/zh/what-is-scope-and-closures.md"},{"file_name":"network-notes-part1.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/network-notes-part1.md","raw_content":"---\ntitle: 网络基础知识备忘录(一)\nlang: zh\ndate: 2018-09-17 21:17:37\ncover: /assets/4.jpg\ntags:\n- network\n---\n\n> 对于我来说网络知识是属于比较抽象的部分，很多东西不记录下来很快就会忘记。所以有了这个网络基础知识的备忘录。这是第一部分，[第二部分见这里](https://kexin-li.github.io/zh/2018/10/08/network-notes-part2/) :)\n\n<!-- more -->\n\n## URI & URL\n\nURL(Uniform Resource Locator): 统一资源定位符。URL 就是我们平时在浏览器中输入的网址，比如 https://kexin-li.github.io 就是 URL。\nURI(Uniform Resource Identifier): 统一资源标识符。\n\n**Uniform:** 规定统一的格式用于方便地处理不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式，另外加入新增的协议方案（如 http: 或 ftp:）也更容易。\n**Resource:** 资源的定义是“可标识的任何东西”，除了文档文件、图片或服务等能够区别于其他类型的，全都可作为资源。并且资源不仅仅是单一的，也可以是多数的集合体。\n**Identifier:** 表示可标识的对象。\n\n综上，URI 就是由某个协议方案表示的资源的定位标识符。\n\nURI 用字符串标识某一互联网资源，而 URL 表示资源的地址。**URL 是 URI 的子集。**\n\n### URI 的格式\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/uri.png\" alt=\"URI Format\"/><figcaption>URI Format</figcaption></figure>\n\n其中，登录信息、服务器端口号、查询字符串和片段标识符为可选项。\n\n## DNS\n\nDNS(Domain Name System) 服务是和 HTTP 协议一样位于应用层的协议，DNS 主要提供域名到 IP 地址的解析服务。用户使用域名而非 IP 地址来访问对方的计算机，因为这比较符合人类的记忆习惯，但要让计算机去理解名称就有点难度了，因此 DNS 就充当了“翻译官”的角色，来将域名翻译成计算机更容易理解的 IP 数字串。\n\nDNS 协议通过域名查找 IP 地址，或者逆向从 IP 反查找域名。\n\nDNS 具体是如何工作的可参考[这篇文章](https://www.cloudflare.com/learning/dns/what-is-dns/)。\n\n## TCP/IP 协议族\n\n计算机与网络设备互相通信，双方需要基于相同的规则，我们把这种规则叫做协议（protocol），而协议中存在各式各样的内容，像这样把互联网相关联的协议集合起来总称为 TCP/IP。通常使用的网络都是在 TCP/IP 协议族的基础上运作的，比如 HTTP 协议就是它内部的一个子集。\n\n在 TCP/IP 协议族里最重要的一点是分层，它按层次分别分为以下四层：应用层、传输层、网络层和数据链路层。将 TCP/IP 层次化的好处是，我们只需要定好各层的接口，有变动时只需要更改对应层而不需要更改全部，各层之内也能自由设计，这也是所谓的“模块化”吧。\n\n各层的作用如下：\n\n**应用层**\n应用层决定了向用户提供应用服务时通信的活动。比如 FTP(File Transfer Protocol, 文件传输协议)，DNS(Domain Name System, 域名系统) 和 HTTP 协议都在这层。\n\n**传输层**\n传输层对于上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User Data Protocol, 用户数据报协议)。\n\n**网络层**\n网络层用来处理在网络上流动的数据包。数据包是网络传输的最小单位，该层规定了通过怎样的路径（即传输线路）到达对方计算机，并把数据包传给对方。\n\n**链路层**\n用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡及光纤等物理可见部分。硬件上的范畴均属于链路层的作用范围之内。\n\n利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方计算机通信。发送端从应用层往下走，接收端则从链路层往上走。\n\n以 HTTP 举例来说，对于发送端：\n\n- 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。\n- 接着为了传输方便，在传输层（TCP 协议）把从应用层收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n- 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。\n\n而对于接收端，在链路层接收到数据后，按序向上转发，一直到应用层。\n\n另外，发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息；而接收端在层与层之间传输数据时，每经过一层时会把对应的首部去掉。这种把数据信息包装起来的做法称为封装（encapsulate）。\n\n### IP 协议\n\nIP(Internet Protocol) 协议位于 TCP/IP 协议族的网络层。几乎所有使用网络的系统都会用到 IP 协议，它的作用时把各种数据包传送给对方。而要保证确实送到对方那里，则需要满足各类条件，其中两个重要条件是 IP 地址和 MAC 地址（Media Access Control Address）。\n\nIP 地址指明了节点被分配到的地址，是可变的，MAC 地址指网卡所属的固定地址，是不可变的。IP 地址可以和 MAC 地址进行配对。\n\nIP 间的通信依赖 MAC 地址，ARP 协议（Address Resolution Protocol）是一种解析地址的协议，能够根据通信方的 IP 地址反查出对应的 MAC 地址。在网络上，通常是经过多台计算机和网络设备中转才能连接对方，而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。\n\n### TCP 协议\n\nTCP(Transmission Control Protocol) 协议位于传输层，提供可靠的字节流服务。字节流服务是指将大块数据分割成以报文段（segment）为单位的数据包进行管理，而可靠的传输服务是指能够准确地把数据传给对方。\n\n**三次握手策略**\n\n为了保证传输的可靠性，TCP 协议采用三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，它不会就置之不理了，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志 SYN(synchronize) 和 ACK(acknowledgement)。\n\n三次握手的过程如下：\n\n- 发送端首先发送一个带 SYN 标志的数据包给对方。\n- 接收端收到后，回传一个 SYN/ACK 标志的数据以示确认信息。\n- 发送端再回传一个带 ACK 标志的数据包，代表握手结束。\n\n若握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。\n\n图示过程如下：\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/tcp-shaking.png\" alt=\"tcp shaking\"/><figcaption>TCP 三次握手过程</figcaption></figure>\n\n### HTTP 协议\n\nHTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务端之间的通信。它通过请求和响应交换达成通信，其中客户端发送请求，服务端响应请求。\n\n客户端请求报文是由请求方法、请求 URI（用于定位资源）、协议版本、可选的请求首部字段和内容实体构成的。\n\n```\n方法     URI       协议版本\nPOST  /form/entry  HTTP/1.1\n\n请求首部字段\nHost: hackr.jp\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 16\n\n内容实体\nname-ueno&age=37\n```\n\n服务器接收到请求后，会将请求内容的处理结果以响应的形式返回。响应报文基本上由协议版本、状态码、用以解释状态码的原因的短语、可选的响应首部字段以及实体主体构成。\n\n```\n协议版本  状态码   状态码的原因短语\nHTTP/1.1   200     OK\n\n响应首部字段\nDate: Tue, 18 Sep 2018 06:20:47 GMT\nContent-Length: 362\nContent-Type: text/html\n\n资源主体（entity body）\n<html>\n...\n```\n\n**HTTP/1.1 请求方法**\nHTTP/1.1 支持的方法和 HTTP/1.0 支持的方法有所不同，这里只列举了 HTTP/1.1 所支持的方法。另外，方法名区分大小写。\n\n**GET: 获取资源**\nGET 方法用来请求访问已被 URI 识别的资源，指定的资源经服务器解析后返回的响应内容。\n\n**POST: 传输实体主体**\nPOST 方法用来传输实体的主体。\n\n**PUT: 传输文件**\nPUT 方法用来传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但由于此方法自身不带任何验证机制，任何人都可以上传，因此存在安全性问题，一般不使用该方法。若配合 Web App 的验证机制，或架构设计采用 REST 标准的同类 Web 网站，则可能使用该方法。\n\n**HEAD: 获得报文首部**\nHEAD 方法和 GET 方法一样，只是不返回报文主体内容，只返回首部。用于确认 URI 的有效性及资源更新的日期时间等。\n\n**DELETE: 删除文件**\nDELETE 方法和 PUT 方法相反，用于删除指定资源。但和 PUT 方法一样，不带验证机制，存在安全性问题，一般也不使用该方法。\n\n**OPTIONS: 询问支持的方法**\nOPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。\n\n**TRACE: 追踪路径**\nTRACE 方法让 Web 服务器端将之前的请求通信环回给客户端。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这样因为请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认这一连接过程中发生了什么的。但由于此方法容易导致 XST(Cross-Site Tracing, 跨域追踪)，因此基本不用。\n\n**CONNECT: 要求用隧道协议连接代理**\nCONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL(Secure Sockets Layer, 安全套接层) 和 TLS(Transport Layer Security, 传输层安全) 协议把通信内容加密后经网络隧道传输。\n\n### Cookie\n\nHTTP 协议是一种不保存状态，即无状态（stateless）的协议。也就是说协议本身不保存之前一切的请求或响应报文信息，这样设计的好处在于能够更快地处理大量事务，但随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况越来越多。比如用户登录到一家购物网站，即使它跳转到其他页面后，也需要保持登录状态。因此，[Cookie 技术](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)应运而生。Cookie技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。\n\nCookie 会根据服务端发送的响应报文内一个叫做 `Set-Cookie` 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。此时的服务端会根据 Cookie 去检查是哪一个客户端发来的信息，对比服务器上的内容得到之前的状态信息。\n\n## HTTP 报文\n\n用于 HTTP 协议交互的信息被称为 HTTP 报文，它是 HTTP 通信中的基本单位。报文是由多行数据构成的字符串文本。请求端的叫请求报文，响应端的叫响应报文。HTTP 报文大致可分为报文首部和报文主体两部分，报文主体可以不存在。\n\n报文首部由以下数据组成：\n\n- 请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。\n- 状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。\n- 首部字段：包含表示各种请求和响应的条件和属性的首部，一般有通用首部、请求首部、响应首部和实体首部四种。\n- 其他：可能包含 HTTP 的 RFC 里未定义的首部(Cookie 等)。\n\n### HTTP 报文首部\n\nHTTP 请求报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。HTTP 响应报文由 HTTP 版本、状态码(数字和原因短语)、HTTP 首部字段 3 部分构成。HTTP 首部字段的信息最为丰富，根据实际用途可以被分为以下 4 种类型：\n\n- 通用首部字段：请求报文和响应报文两方都会使用的首部。\n- 请求首部字段：从客户端向服务端发送请求报文时使用的首部。\n- 响应首部字段：从服务端向客户端返回响应报文时使用的首部。\n- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。\n\n**通用首部字段：**\n\n- Cache-Control\n- Connection\n- Date\n- Pragma\n- Trailer\n- Transfer-Encoding\n- Upgrade\n- Via\n- Warning\n\n**请求首部字段：**\n\n- Accept\n- Accept-Charset\n- Accept-Encoding\n- Accept-Language\n- Authorization\n- Expect\n- Form\n- Host\n- If-Match\n- If-Modified-Since\n- If-None-Match\n- If-Range\n- If-Unmodified-Since\n- Max-forwards\n- Proxy-Authorization\n- Range\n- Referer\n- TE\n- User-Agent\n\n**响应首部字段：**\n\n- Accept-Ranges\n- Age\n- ETag\n- Location\n- Proxy-Authenticate\n- Retry-After\n- Server\n- Vary\n- WWW-Authenticate\n\n**实体首部字段：**\n\n- Allow\n- Content-Encoding\n- Content-Language\n- Content-Length\n- Content-Location\n- Content-MD5\n- Content-Range\n- Content-Type\n- Expires\n- Last-Modified\n\n**为 Cookie 服务的首部字段：**\n\n- Set-Cookie\n- Cookie\n\n## HTTP 状态码\n\n状态码用来描述客户端向服务端发送请求后的结果。借助状态码就可以分析服务端是否正常处理了请求。状态码的类别如下：\n\n- 1XX: Informational, 接收的请求正在处理。\n- 2XX: Success, 请求正常处理完毕。\n- 3XX: Redirection, 需要进行附加操作以完成请求。\n- 4XX: Client Error, 服务器无法处理请求。\n- 5XX: Server Error, 服务器处理请求出错。\n\n### 2XX\n\n2XX 的响应结果表明请求被正常处理了。\n\n**200 OK**\n表示从客户端发来的请求在服务端被正常处理了。\n\n**204 No Content**\n表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。\n\n**206 Partial Content**\n表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。\n\n### 3XX\n\n3XX 的响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n**301 Moved Permanently**\n表示永久性重定向。即请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。\n\n**302 Found**\n表示临时性重定向。即请求的资源已被分配了新的 URI，希望用户本次能使用新的 URI 访问。\n\n**303 See Other**\n表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。\n\n**304 Not Modified**\n表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件。304 虽然被划分在 3XX 类别中，但和重定向没有关系。\n\n**307 Temporary Redirect**\n与 302 有着相同的含义。\n\n### 4XX\n\n4XX 的响应结果表明客户端是发生错误的原因所在。\n\n**400 Bad Request**\n表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。\n\n**401 Unauthorized**\n表示发送的请求需要有通过 HTTP 认证的认证信息。\n\n**403 Forbidden**\n表示对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题等等都可能是发生 403 的原因。\n\n**404 Not Found**\n表示服务器上无法找到请求的资源。\n\n### 5XX\n\n5XX 的响应结果表明服务器是发生错误的原因所在。\n\n**500 Internal Server Error**\n表示服务器在执行请求时发生了错误。\n\n**503 Service Unavailable**\n表示服务器正处于超负载或正在停机维护的状态，而无法处理请求。","title":"网络基础知识备忘录(一)","lang":"zh","date":"2018-09-17T13:17:37.000Z","cover":"/assets/4.jpg","tags":["network"],"_content":"\n> 对于我来说网络知识是属于比较抽象的部分，很多东西不记录下来很快就会忘记。所以有了这个网络基础知识的备忘录。这是第一部分，[第二部分见这里](https://kexin-li.github.io/zh/2018/10/08/network-notes-part2/) :)\n\n<!-- more -->\n\n## URI & URL\n\nURL(Uniform Resource Locator): 统一资源定位符。URL 就是我们平时在浏览器中输入的网址，比如 https://kexin-li.github.io 就是 URL。\nURI(Uniform Resource Identifier): 统一资源标识符。\n\n**Uniform:** 规定统一的格式用于方便地处理不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式，另外加入新增的协议方案（如 http: 或 ftp:）也更容易。\n**Resource:** 资源的定义是“可标识的任何东西”，除了文档文件、图片或服务等能够区别于其他类型的，全都可作为资源。并且资源不仅仅是单一的，也可以是多数的集合体。\n**Identifier:** 表示可标识的对象。\n\n综上，URI 就是由某个协议方案表示的资源的定位标识符。\n\nURI 用字符串标识某一互联网资源，而 URL 表示资源的地址。**URL 是 URI 的子集。**\n\n### URI 的格式\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/uri.png\" alt=\"URI Format\"/><figcaption>URI Format</figcaption></figure>\n\n其中，登录信息、服务器端口号、查询字符串和片段标识符为可选项。\n\n## DNS\n\nDNS(Domain Name System) 服务是和 HTTP 协议一样位于应用层的协议，DNS 主要提供域名到 IP 地址的解析服务。用户使用域名而非 IP 地址来访问对方的计算机，因为这比较符合人类的记忆习惯，但要让计算机去理解名称就有点难度了，因此 DNS 就充当了“翻译官”的角色，来将域名翻译成计算机更容易理解的 IP 数字串。\n\nDNS 协议通过域名查找 IP 地址，或者逆向从 IP 反查找域名。\n\nDNS 具体是如何工作的可参考[这篇文章](https://www.cloudflare.com/learning/dns/what-is-dns/)。\n\n## TCP/IP 协议族\n\n计算机与网络设备互相通信，双方需要基于相同的规则，我们把这种规则叫做协议（protocol），而协议中存在各式各样的内容，像这样把互联网相关联的协议集合起来总称为 TCP/IP。通常使用的网络都是在 TCP/IP 协议族的基础上运作的，比如 HTTP 协议就是它内部的一个子集。\n\n在 TCP/IP 协议族里最重要的一点是分层，它按层次分别分为以下四层：应用层、传输层、网络层和数据链路层。将 TCP/IP 层次化的好处是，我们只需要定好各层的接口，有变动时只需要更改对应层而不需要更改全部，各层之内也能自由设计，这也是所谓的“模块化”吧。\n\n各层的作用如下：\n\n**应用层**\n应用层决定了向用户提供应用服务时通信的活动。比如 FTP(File Transfer Protocol, 文件传输协议)，DNS(Domain Name System, 域名系统) 和 HTTP 协议都在这层。\n\n**传输层**\n传输层对于上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User Data Protocol, 用户数据报协议)。\n\n**网络层**\n网络层用来处理在网络上流动的数据包。数据包是网络传输的最小单位，该层规定了通过怎样的路径（即传输线路）到达对方计算机，并把数据包传给对方。\n\n**链路层**\n用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡及光纤等物理可见部分。硬件上的范畴均属于链路层的作用范围之内。\n\n利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方计算机通信。发送端从应用层往下走，接收端则从链路层往上走。\n\n以 HTTP 举例来说，对于发送端：\n\n- 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。\n- 接着为了传输方便，在传输层（TCP 协议）把从应用层收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n- 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。\n\n而对于接收端，在链路层接收到数据后，按序向上转发，一直到应用层。\n\n另外，发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息；而接收端在层与层之间传输数据时，每经过一层时会把对应的首部去掉。这种把数据信息包装起来的做法称为封装（encapsulate）。\n\n### IP 协议\n\nIP(Internet Protocol) 协议位于 TCP/IP 协议族的网络层。几乎所有使用网络的系统都会用到 IP 协议，它的作用时把各种数据包传送给对方。而要保证确实送到对方那里，则需要满足各类条件，其中两个重要条件是 IP 地址和 MAC 地址（Media Access Control Address）。\n\nIP 地址指明了节点被分配到的地址，是可变的，MAC 地址指网卡所属的固定地址，是不可变的。IP 地址可以和 MAC 地址进行配对。\n\nIP 间的通信依赖 MAC 地址，ARP 协议（Address Resolution Protocol）是一种解析地址的协议，能够根据通信方的 IP 地址反查出对应的 MAC 地址。在网络上，通常是经过多台计算机和网络设备中转才能连接对方，而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。\n\n### TCP 协议\n\nTCP(Transmission Control Protocol) 协议位于传输层，提供可靠的字节流服务。字节流服务是指将大块数据分割成以报文段（segment）为单位的数据包进行管理，而可靠的传输服务是指能够准确地把数据传给对方。\n\n**三次握手策略**\n\n为了保证传输的可靠性，TCP 协议采用三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，它不会就置之不理了，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志 SYN(synchronize) 和 ACK(acknowledgement)。\n\n三次握手的过程如下：\n\n- 发送端首先发送一个带 SYN 标志的数据包给对方。\n- 接收端收到后，回传一个 SYN/ACK 标志的数据以示确认信息。\n- 发送端再回传一个带 ACK 标志的数据包，代表握手结束。\n\n若握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。\n\n图示过程如下：\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/tcp-shaking.png\" alt=\"tcp shaking\"/><figcaption>TCP 三次握手过程</figcaption></figure>\n\n### HTTP 协议\n\nHTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务端之间的通信。它通过请求和响应交换达成通信，其中客户端发送请求，服务端响应请求。\n\n客户端请求报文是由请求方法、请求 URI（用于定位资源）、协议版本、可选的请求首部字段和内容实体构成的。\n\n```\n方法     URI       协议版本\nPOST  /form/entry  HTTP/1.1\n\n请求首部字段\nHost: hackr.jp\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 16\n\n内容实体\nname-ueno&age=37\n```\n\n服务器接收到请求后，会将请求内容的处理结果以响应的形式返回。响应报文基本上由协议版本、状态码、用以解释状态码的原因的短语、可选的响应首部字段以及实体主体构成。\n\n```\n协议版本  状态码   状态码的原因短语\nHTTP/1.1   200     OK\n\n响应首部字段\nDate: Tue, 18 Sep 2018 06:20:47 GMT\nContent-Length: 362\nContent-Type: text/html\n\n资源主体（entity body）\n<html>\n...\n```\n\n**HTTP/1.1 请求方法**\nHTTP/1.1 支持的方法和 HTTP/1.0 支持的方法有所不同，这里只列举了 HTTP/1.1 所支持的方法。另外，方法名区分大小写。\n\n**GET: 获取资源**\nGET 方法用来请求访问已被 URI 识别的资源，指定的资源经服务器解析后返回的响应内容。\n\n**POST: 传输实体主体**\nPOST 方法用来传输实体的主体。\n\n**PUT: 传输文件**\nPUT 方法用来传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但由于此方法自身不带任何验证机制，任何人都可以上传，因此存在安全性问题，一般不使用该方法。若配合 Web App 的验证机制，或架构设计采用 REST 标准的同类 Web 网站，则可能使用该方法。\n\n**HEAD: 获得报文首部**\nHEAD 方法和 GET 方法一样，只是不返回报文主体内容，只返回首部。用于确认 URI 的有效性及资源更新的日期时间等。\n\n**DELETE: 删除文件**\nDELETE 方法和 PUT 方法相反，用于删除指定资源。但和 PUT 方法一样，不带验证机制，存在安全性问题，一般也不使用该方法。\n\n**OPTIONS: 询问支持的方法**\nOPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。\n\n**TRACE: 追踪路径**\nTRACE 方法让 Web 服务器端将之前的请求通信环回给客户端。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这样因为请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认这一连接过程中发生了什么的。但由于此方法容易导致 XST(Cross-Site Tracing, 跨域追踪)，因此基本不用。\n\n**CONNECT: 要求用隧道协议连接代理**\nCONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL(Secure Sockets Layer, 安全套接层) 和 TLS(Transport Layer Security, 传输层安全) 协议把通信内容加密后经网络隧道传输。\n\n### Cookie\n\nHTTP 协议是一种不保存状态，即无状态（stateless）的协议。也就是说协议本身不保存之前一切的请求或响应报文信息，这样设计的好处在于能够更快地处理大量事务，但随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况越来越多。比如用户登录到一家购物网站，即使它跳转到其他页面后，也需要保持登录状态。因此，[Cookie 技术](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)应运而生。Cookie技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。\n\nCookie 会根据服务端发送的响应报文内一个叫做 `Set-Cookie` 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。此时的服务端会根据 Cookie 去检查是哪一个客户端发来的信息，对比服务器上的内容得到之前的状态信息。\n\n## HTTP 报文\n\n用于 HTTP 协议交互的信息被称为 HTTP 报文，它是 HTTP 通信中的基本单位。报文是由多行数据构成的字符串文本。请求端的叫请求报文，响应端的叫响应报文。HTTP 报文大致可分为报文首部和报文主体两部分，报文主体可以不存在。\n\n报文首部由以下数据组成：\n\n- 请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。\n- 状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。\n- 首部字段：包含表示各种请求和响应的条件和属性的首部，一般有通用首部、请求首部、响应首部和实体首部四种。\n- 其他：可能包含 HTTP 的 RFC 里未定义的首部(Cookie 等)。\n\n### HTTP 报文首部\n\nHTTP 请求报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。HTTP 响应报文由 HTTP 版本、状态码(数字和原因短语)、HTTP 首部字段 3 部分构成。HTTP 首部字段的信息最为丰富，根据实际用途可以被分为以下 4 种类型：\n\n- 通用首部字段：请求报文和响应报文两方都会使用的首部。\n- 请求首部字段：从客户端向服务端发送请求报文时使用的首部。\n- 响应首部字段：从服务端向客户端返回响应报文时使用的首部。\n- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。\n\n**通用首部字段：**\n\n- Cache-Control\n- Connection\n- Date\n- Pragma\n- Trailer\n- Transfer-Encoding\n- Upgrade\n- Via\n- Warning\n\n**请求首部字段：**\n\n- Accept\n- Accept-Charset\n- Accept-Encoding\n- Accept-Language\n- Authorization\n- Expect\n- Form\n- Host\n- If-Match\n- If-Modified-Since\n- If-None-Match\n- If-Range\n- If-Unmodified-Since\n- Max-forwards\n- Proxy-Authorization\n- Range\n- Referer\n- TE\n- User-Agent\n\n**响应首部字段：**\n\n- Accept-Ranges\n- Age\n- ETag\n- Location\n- Proxy-Authenticate\n- Retry-After\n- Server\n- Vary\n- WWW-Authenticate\n\n**实体首部字段：**\n\n- Allow\n- Content-Encoding\n- Content-Language\n- Content-Length\n- Content-Location\n- Content-MD5\n- Content-Range\n- Content-Type\n- Expires\n- Last-Modified\n\n**为 Cookie 服务的首部字段：**\n\n- Set-Cookie\n- Cookie\n\n## HTTP 状态码\n\n状态码用来描述客户端向服务端发送请求后的结果。借助状态码就可以分析服务端是否正常处理了请求。状态码的类别如下：\n\n- 1XX: Informational, 接收的请求正在处理。\n- 2XX: Success, 请求正常处理完毕。\n- 3XX: Redirection, 需要进行附加操作以完成请求。\n- 4XX: Client Error, 服务器无法处理请求。\n- 5XX: Server Error, 服务器处理请求出错。\n\n### 2XX\n\n2XX 的响应结果表明请求被正常处理了。\n\n**200 OK**\n表示从客户端发来的请求在服务端被正常处理了。\n\n**204 No Content**\n表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。\n\n**206 Partial Content**\n表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。\n\n### 3XX\n\n3XX 的响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n**301 Moved Permanently**\n表示永久性重定向。即请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。\n\n**302 Found**\n表示临时性重定向。即请求的资源已被分配了新的 URI，希望用户本次能使用新的 URI 访问。\n\n**303 See Other**\n表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。\n\n**304 Not Modified**\n表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件。304 虽然被划分在 3XX 类别中，但和重定向没有关系。\n\n**307 Temporary Redirect**\n与 302 有着相同的含义。\n\n### 4XX\n\n4XX 的响应结果表明客户端是发生错误的原因所在。\n\n**400 Bad Request**\n表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。\n\n**401 Unauthorized**\n表示发送的请求需要有通过 HTTP 认证的认证信息。\n\n**403 Forbidden**\n表示对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题等等都可能是发生 403 的原因。\n\n**404 Not Found**\n表示服务器上无法找到请求的资源。\n\n### 5XX\n\n5XX 的响应结果表明服务器是发生错误的原因所在。\n\n**500 Internal Server Error**\n表示服务器在执行请求时发生了错误。\n\n**503 Service Unavailable**\n表示服务器正处于超负载或正在停机维护的状态，而无法处理请求。","date_unix":1537190257000,"page_url":"_posts/zh/network-notes-part1.md"},{"file_name":"how-react-works.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/zh/how-react-works.md","raw_content":"---\ntitle: 解析 React 工作流程\ndate: 2018-09-14 16:51:38\ncover: /assets/3.jpg\ntags:\n- react\n- how stuff works\n- javascript\n---\n\n说起 React，可能脑海中浮现的第一句代码应该是 `ReactDOM.render(<App />, root)`。这一句代码很像 DOM 操作中的这句代码 `document.appendChild(App, root)`。然而对于 React 来说，将 App 节点加载在 root 节点之后的这个过程中还发生了很多故事，比如 `<App />` 是如何转换为一个 DOM 节点的，`App` 和 `<App />` 又有什么关系，render() 这个函数又做了什么等等。\n\n<!-- more -->\n\n这句代码所描述的场景可以称之为 Mounting，也就是加载一个组件到实际 DOM。\n\n除了 Mounting 是 React 的主要功能之外，另外一个主要功能就是 Updating。在写原生 JS 的时候，当监测到用户响应，就会直接操作 DOM 呈现响应后的结果。而对于一个大型的应用，频繁地直接操作 DOM，将会增大 GPU 的消耗。React 的出现不仅仅实现了组件化编程，更是降低了直接操作实际 DOM 的频率。React 在内部会绘制出一棵 Virtual DOM Tree，它其实是一个 JavaScript Object。当监测到用户响应需要更新页面时，React 会根据新的 UI 绘制出一棵新的 Virtual DOM Tree，通过 Diff 算法对比旧的 Virtual DOM Tree，计算出差异有选择性地更新到实际的 DOM 中。这样做虽然降低了直接操作 DOM 的频率，但牺牲了操作实际 DOM 的速度。\n\n## Mounting\n\n了解加载过程，首先需要了解 React 是如何实现组件化编程的。在 React 中，组件（Component）并不是最小单位，元素（Element）才是。Element 是一个 JavaScript Object，里面保存着组件 的信息，而 Component 可以是 functional component, class component, 或者一个 `<div>`, `<p>` 等等。所以 Component 是一个纯函数，一个类，或者一个 HTML Tag。我们平常写的 JSX，虽然看起来像是一句句 HTML，但最终都被 Babel 转换为了一个 Element 对象，保存着这个组件的信息。刚刚的这句代码 `ReactDOM.render(<App />, root)`，其中 `<App />` 其实是 Element，而 `App` 才是一个 Component。\n\n在实现 Mounting 的过程中，将经历三次转换。\n\n**JSX --> Element**\n\nJSX 将在 Babel 的作用下被编译为 `React.createElement()` 函数，其参数是拆解了 JSX 将它们装进一个 JavaScript Object。这个 Object 在 `createElement` 函数的作用下变成了一个 Element 对象。至于这两个对象有什么区别，其实区别不大，只是修改了 Object 内 property 的组合方式而已。我们只要知道，Element 对象内的信息就是写的 JSX 信息，同一个信息的不同表示。\n\n**Element --> Component**\n\n之前说到 Component 可以有好几种类型，具体有以下几种类型：\n\n- DOMComponent: Platform-Sepcific Component, `div`, `span` 等等。\n- CompositeComponent: User-defined Component\n  - functional component: 没有 local state 和 lifecycle\n  - class component: 有 local state 和 lifecycle\n- TextComponent: number or string\n\nReact 将这几种 Component 各自封装成类，这个类中包含了 `mount()` 方法，`update()` 方法以及其他信息。Element 向 Component 转换的过程也就是实例化各自类的过程。根据 Element 中描述 Component 类型的 type 属性来实例化相应的 Component 类。\n\n**Component --> Real Node**\n\n在不同的 Component 类中，也有不同的 `mount()` 方法实现，来将 Component 转换为 Real Node。\n\n对于 CompositeComponent 来说，它不会做真正的 `document.createElement()` 这种操作，而是将 mount 操作 defer 到 DOMComponent。对于 DOMComponent，主要做了三件事，一是创建 Real Node，二是将 attribute 从 Component 映射到 Real Node 中，二是递归其子 Component，若是遇到 CompositeComponent，收集信息并 defer 到 DOMComponent，若是遇到 DOMComponent，创建 Real Node。如此往复。\n\n总结 Mounting 的流程为：\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/mounting.jpg\" alt=\"React Mounting\"/><figcaption>React Mounting 流程图</figcaption></figure>\n\n## Updating\n\n在写原生 JS 的时候，UI 的更新通常是需要用户触发某个操作。在 React 中，UI 的更新来自于组件的 props 或 local state 的变化，这两种变化也间接是由用户响应导致。因此，当 props 或 local state 改变了之后，React 是如何将 Component 更新到实际的 DOM 上的呢？\n\n### Stack Reconciler\n\nReact 在加载完组件后，将生成 Virtual DOM Tree，就是一棵保存了所有节点信息的树，同时它是 JavaScript Object。当 UI 需要更新时，将生成一棵新的 Tree。通过 Diff 算法进行遍历和比较 Virtual DOM Tree 找出差异点，这个过程叫做 [Reconciler](https://reactjs.org/docs/reconciliation.html)。在 React 15 及之前，都是通过 Stack Reconciler 来实现更新过程。而在 React 16 之后，React 发布了优化后的 React Fiber 算法。[React 所使用的 Diff 算法是假设以下两个条件成立的 O(N) 算法](https://reactjs.org/docs/reconciliation.html#motivation)。\n\n- 不同类型的 Element 会生成不同的子树。例如 div 变化成 ul，或者 `<Counter />` 变为 `<Header />`。\n- 通过 key 这个属性，React 可以得知在重绘中需要具体更新哪几个节点。\n\n通过 Diff，会找出需要插入（insert）的新节点，需要移除（remove）的节点，和需要调整顺序（move）的节点。这时不会马上对这些需要调整的节点执行操作，而是将它们保存在一个数组或者对象的数据结构里，将操作和节点信息一一对应，最后统一执行 DOM 操作。这个过程和 JS, Java 等的内存回收机制有点像，都是一种“先标记再清除”的算法。\n\n### Fiber Reconciler\n\n[Fiber Reconciler](https://github.com/acdlite/react-fiber-architecture) 优化了Stack Reconciler 如同函数调用栈的策略，它一定要等整棵 Virtual DOM 计算完成之后，才将任务出栈释放主线程。Fiber Reconciler 将任务（渲染，更新等）拆分成一系列的小任务，每次检查树上的一小部分，完成后确认否还有时间继续下一个任务，存在时继续，不存在下一个任务时自己挂起，主线程不忙的时候再继续，变成一种可切分，可中断的模式从而提高效率。\n\n更多请参考[这篇文章](https://juejin.im/entry/5b2910c3f265da599f68c981)。\n\n总结 Updating 的流程为：\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/updating.png\" alt=\"React Updating\"/><figcaption>React Updating 流程图</figcaption></figure>\n\n## 参考资料\n\n- https://reactjs.org/docs/implementation-notes.html\n- https://reactjs.org/docs/reconciliation.html\n- https://github.com/cyan33/learn-react-source-code\n","title":"解析 React 工作流程","date":"2018-09-14T08:51:38.000Z","cover":"/assets/3.jpg","tags":["react","how stuff works","javascript"],"_content":"\n说起 React，可能脑海中浮现的第一句代码应该是 `ReactDOM.render(<App />, root)`。这一句代码很像 DOM 操作中的这句代码 `document.appendChild(App, root)`。然而对于 React 来说，将 App 节点加载在 root 节点之后的这个过程中还发生了很多故事，比如 `<App />` 是如何转换为一个 DOM 节点的，`App` 和 `<App />` 又有什么关系，render() 这个函数又做了什么等等。\n\n<!-- more -->\n\n这句代码所描述的场景可以称之为 Mounting，也就是加载一个组件到实际 DOM。\n\n除了 Mounting 是 React 的主要功能之外，另外一个主要功能就是 Updating。在写原生 JS 的时候，当监测到用户响应，就会直接操作 DOM 呈现响应后的结果。而对于一个大型的应用，频繁地直接操作 DOM，将会增大 GPU 的消耗。React 的出现不仅仅实现了组件化编程，更是降低了直接操作实际 DOM 的频率。React 在内部会绘制出一棵 Virtual DOM Tree，它其实是一个 JavaScript Object。当监测到用户响应需要更新页面时，React 会根据新的 UI 绘制出一棵新的 Virtual DOM Tree，通过 Diff 算法对比旧的 Virtual DOM Tree，计算出差异有选择性地更新到实际的 DOM 中。这样做虽然降低了直接操作 DOM 的频率，但牺牲了操作实际 DOM 的速度。\n\n## Mounting\n\n了解加载过程，首先需要了解 React 是如何实现组件化编程的。在 React 中，组件（Component）并不是最小单位，元素（Element）才是。Element 是一个 JavaScript Object，里面保存着组件 的信息，而 Component 可以是 functional component, class component, 或者一个 `<div>`, `<p>` 等等。所以 Component 是一个纯函数，一个类，或者一个 HTML Tag。我们平常写的 JSX，虽然看起来像是一句句 HTML，但最终都被 Babel 转换为了一个 Element 对象，保存着这个组件的信息。刚刚的这句代码 `ReactDOM.render(<App />, root)`，其中 `<App />` 其实是 Element，而 `App` 才是一个 Component。\n\n在实现 Mounting 的过程中，将经历三次转换。\n\n**JSX --> Element**\n\nJSX 将在 Babel 的作用下被编译为 `React.createElement()` 函数，其参数是拆解了 JSX 将它们装进一个 JavaScript Object。这个 Object 在 `createElement` 函数的作用下变成了一个 Element 对象。至于这两个对象有什么区别，其实区别不大，只是修改了 Object 内 property 的组合方式而已。我们只要知道，Element 对象内的信息就是写的 JSX 信息，同一个信息的不同表示。\n\n**Element --> Component**\n\n之前说到 Component 可以有好几种类型，具体有以下几种类型：\n\n- DOMComponent: Platform-Sepcific Component, `div`, `span` 等等。\n- CompositeComponent: User-defined Component\n  - functional component: 没有 local state 和 lifecycle\n  - class component: 有 local state 和 lifecycle\n- TextComponent: number or string\n\nReact 将这几种 Component 各自封装成类，这个类中包含了 `mount()` 方法，`update()` 方法以及其他信息。Element 向 Component 转换的过程也就是实例化各自类的过程。根据 Element 中描述 Component 类型的 type 属性来实例化相应的 Component 类。\n\n**Component --> Real Node**\n\n在不同的 Component 类中，也有不同的 `mount()` 方法实现，来将 Component 转换为 Real Node。\n\n对于 CompositeComponent 来说，它不会做真正的 `document.createElement()` 这种操作，而是将 mount 操作 defer 到 DOMComponent。对于 DOMComponent，主要做了三件事，一是创建 Real Node，二是将 attribute 从 Component 映射到 Real Node 中，二是递归其子 Component，若是遇到 CompositeComponent，收集信息并 defer 到 DOMComponent，若是遇到 DOMComponent，创建 Real Node。如此往复。\n\n总结 Mounting 的流程为：\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/mounting.jpg\" alt=\"React Mounting\"/><figcaption>React Mounting 流程图</figcaption></figure>\n\n## Updating\n\n在写原生 JS 的时候，UI 的更新通常是需要用户触发某个操作。在 React 中，UI 的更新来自于组件的 props 或 local state 的变化，这两种变化也间接是由用户响应导致。因此，当 props 或 local state 改变了之后，React 是如何将 Component 更新到实际的 DOM 上的呢？\n\n### Stack Reconciler\n\nReact 在加载完组件后，将生成 Virtual DOM Tree，就是一棵保存了所有节点信息的树，同时它是 JavaScript Object。当 UI 需要更新时，将生成一棵新的 Tree。通过 Diff 算法进行遍历和比较 Virtual DOM Tree 找出差异点，这个过程叫做 [Reconciler](https://reactjs.org/docs/reconciliation.html)。在 React 15 及之前，都是通过 Stack Reconciler 来实现更新过程。而在 React 16 之后，React 发布了优化后的 React Fiber 算法。[React 所使用的 Diff 算法是假设以下两个条件成立的 O(N) 算法](https://reactjs.org/docs/reconciliation.html#motivation)。\n\n- 不同类型的 Element 会生成不同的子树。例如 div 变化成 ul，或者 `<Counter />` 变为 `<Header />`。\n- 通过 key 这个属性，React 可以得知在重绘中需要具体更新哪几个节点。\n\n通过 Diff，会找出需要插入（insert）的新节点，需要移除（remove）的节点，和需要调整顺序（move）的节点。这时不会马上对这些需要调整的节点执行操作，而是将它们保存在一个数组或者对象的数据结构里，将操作和节点信息一一对应，最后统一执行 DOM 操作。这个过程和 JS, Java 等的内存回收机制有点像，都是一种“先标记再清除”的算法。\n\n### Fiber Reconciler\n\n[Fiber Reconciler](https://github.com/acdlite/react-fiber-architecture) 优化了Stack Reconciler 如同函数调用栈的策略，它一定要等整棵 Virtual DOM 计算完成之后，才将任务出栈释放主线程。Fiber Reconciler 将任务（渲染，更新等）拆分成一系列的小任务，每次检查树上的一小部分，完成后确认否还有时间继续下一个任务，存在时继续，不存在下一个任务时自己挂起，主线程不忙的时候再继续，变成一种可切分，可中断的模式从而提高效率。\n\n更多请参考[这篇文章](https://juejin.im/entry/5b2910c3f265da599f68c981)。\n\n总结 Updating 的流程为：\n\n<figure><img src=\"http://pek9gdw3x.bkt.clouddn.com/updating.png\" alt=\"React Updating\"/><figcaption>React Updating 流程图</figcaption></figure>\n\n## 参考资料\n\n- https://reactjs.org/docs/implementation-notes.html\n- https://reactjs.org/docs/reconciliation.html\n- https://github.com/cyan33/learn-react-source-code\n","date_unix":1536915098000,"page_url":"_posts/zh/how-react-works.md"},{"file_name":"sonnet-18.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/en/sonnet-18.md","raw_content":"---\ntitle: Shall I compare thee to a summer’s day?\nlang: en\ndate: 2018-08-26 20:59:21\ntags: poem\ncover: /assets/6.jpg\n---\n\nShall I compare thee to a summer’s day?\n\nThou art more lovely and more temperate.\n\nRough winds do shake the darling buds of May,\n\nAnd summer’s lease hath all too short a date.\n\n<!-- more -->\n\nSometime too hot the eye of heaven shines,\n\nAnd often is his gold complexion dimmed;\n\nAnd every fair from fair sometime declines,\n\nBy chance, or nature’s changing course, untrimmed;\n\nBut thy eternal summer shall not fade,\n\nNor lose possession of that fair thou ow’st,\n\nNor shall death brag thou wand’rest in his shade,\n\nWhen in eternal lines to Time thou grow’st.\n\nSo long as men can breathe, or eyes can see,\n\nSo long lives this, and this gives life to thee.","title":"Shall I compare thee to a summer’s day?","lang":"en","date":"2018-08-26T12:59:21.000Z","tags":"poem","cover":"/assets/6.jpg","_content":"\nShall I compare thee to a summer’s day?\n\nThou art more lovely and more temperate.\n\nRough winds do shake the darling buds of May,\n\nAnd summer’s lease hath all too short a date.\n\n<!-- more -->\n\nSometime too hot the eye of heaven shines,\n\nAnd often is his gold complexion dimmed;\n\nAnd every fair from fair sometime declines,\n\nBy chance, or nature’s changing course, untrimmed;\n\nBut thy eternal summer shall not fade,\n\nNor lose possession of that fair thou ow’st,\n\nNor shall death brag thou wand’rest in his shade,\n\nWhen in eternal lines to Time thou grow’st.\n\nSo long as men can breathe, or eyes can see,\n\nSo long lives this, and this gives life to thee.","date_unix":1535288361000,"page_url":"_posts/en/sonnet-18.md"},{"file_name":"hello-cicada.md","file_path":"/Users/likexin/Documents/Projects/practice/blog/hexo-git/source/_posts/en/hello-cicada.md","raw_content":"---\ntitle: Hello Cicada\nlang: en\ndate: 2018-08-26 20:29:16\ntags: Cicada\ncover: /assets/2.jpg\n---\n\nHello [Cicada](https://github.com/Kexin-Li/hexo-theme-cicada), Hello World.\n\nCicada is a concise and retro theme for Hexo. It helps you develop and publish your thoughts to the world.\n\n<!-- more -->\n\n<figure><img src=\"/assets/cicada.png\" alt=\"Cicada\"/><figcaption>一张 Cicada 的截图</figcaption></figure>\n\n**Hope You Enjoy It.**\n","title":"Hello Cicada","lang":"en","date":"2018-08-26T12:29:16.000Z","tags":"Cicada","cover":"/assets/2.jpg","_content":"\nHello [Cicada](https://github.com/Kexin-Li/hexo-theme-cicada), Hello World.\n\nCicada is a concise and retro theme for Hexo. It helps you develop and publish your thoughts to the world.\n\n<!-- more -->\n\n<figure><img src=\"/assets/cicada.png\" alt=\"Cicada\"/><figcaption>一张 Cicada 的截图</figcaption></figure>\n\n**Hope You Enjoy It.**\n","date_unix":1535286556000,"page_url":"_posts/en/hello-cicada.md"}],"tags":{"length":8,"react":{"length":2},"algorithm":{"length":1},"node":{"length":2},"javascript":{"length":4},"network":{"length":2},"how stuff works":{"length":1},"poem":{"length":1},"Cicada":{"length":1}}}